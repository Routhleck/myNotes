# 教师信息

YF809
mlinking@126.com

# 考核设计

<img src="D:\Typora_CACHE\image-20220830104012603.png" alt="image-20220830104012603" style="zoom:67%;" />

4 quiz in this class
5 small projects in this class

# 成绩构成

<img src="D:\Typora_CACHE\image-20220830105119190.png" alt="image-20220830105119190" style="zoom:67%;" />

# 参考文献

<img src="D:\Typora_CACHE\image-20220830110845973.png" alt="image-20220830110845973" style="zoom:67%;" />

Msys2

**Machine Cycle:**

- Fetch
- Decode
- Execuate



# 1. Introduction

- 1 goal
  - How to support the CONCURRENT execution of many programs in a von Neumann computer (with 1- or N-PUs)
- 2 roles
  - Resource manager, friendly interface
- 3 levels to understand the internals (Fundamental functions) of OS
  - Manage and dispatch resources [**resources are stable, no cooperation**]
  - Coordinate the programs to use resources (Synchronization and Data consistency) [**resources are stable, cooperation**]
  - Fault tolerance [**resources are unstable , cooperation**]

## Outline

<img src="D:\Typora_CACHE\image-20220920113144962.png" alt="image-20220920113144962" style="zoom:50%;" />

<img src="D:\Typora_CACHE\image-20220906114449336.png" alt="image-20220906114449336" style="zoom:80%;" />

<img src="D:\Typora_CACHE\image-20220906114500231.png" alt="image-20220906114500231" style="zoom:80%;" />

# 2. OS's Construction

## 2.1 Problems and Ideas in OS

### 2.1.1 Complexity is caused by the resource

### 2.1.2 Concurrency makes OS more complicated

### 2.1.3 Problem of resource competition

- Data inconsistency
- Security
- Multi-processor system

### 2.1.4 Class Structure

<img src="D:\Typora_CACHE\image-20220906121048817.png" alt="image-20220906121048817" style="zoom:80%;" />

## 2.2 Construct OS

 We can distill 4 kinds of resources / concepts

- CPU,
- Main Memory
- Hard Disk
- File

### 2.2.1 Simple structure/monolithic structure

<img src="D:\Typora_CACHE\image-20220906121552678.png" alt="image-20220906121552678" style="zoom:80%;" />

### 2.2.2 Modular, Layered, Microkernel

<img src="D:\Typora_CACHE\image-20220906121734377.png" alt="image-20220906121734377" style="zoom:80%;" />

<img src="D:\Typora_CACHE\image-20220906122004449.png" alt="image-20220906122004449" style="zoom:80%;" />

### 2.2.3 Trend - Virtual machine

**multiplexing computers**

<img src="D:\Typora_CACHE\image-20220909104810639.png" alt="image-20220909104810639" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220909105108107.png" alt="image-20220909105108107" style="zoom:67%;" />

## 2.3 How do user use the function defined in OS

- System Call/API

## 2.4 How to load and run OS

when turn on the power of computer, run ROM.

- POSE
- BIOS
- Boot Loader

# 3. Proccess & Thread

## 3.1 Process

• **PCB (Process Control Block)** is the one used/named data structure

1. Process location information
2. Process identification information
3. Process state information
4. Process control information

- **Process Location Information**: Each process image in memory
  - may not occupy a contiguous range of addresses ( depends
    on memory management scheme used, which will be discussed in later
    MM part ).
    - both a private and shared memory address space can be used.

- **Process Identification Information**: A few numeric identifiers may be used
  - Unique process identifier (PID) –
    - indexes (directly or indirectly) into the process table.
  - User identifier (UID) –
    - the user who is responsible for the job.
      - Identifier of the process that created this process (PPID). 
  
- **Processor State Information**: Contents of processor registers
  - User-visible registers
  - Control and status registers
  - Stack pointers
  
- **Process Control Information**: Scheduling and state information
  - Process state (i.e., running, ready, blocked...)
  - Priority of the process
  - Relationship with other processes
    - the process is waiting (if blocked).
    - other PCBs for process queues, parent-child relationships and other
      structures

Process Transitions (1)

- Ready → Running
  - When it is time, the dispatcher selects a new process to run.
- Running → Ready
  - the running process has expired his time slot.
  - the running process gets interrupted because a higher priority process is in the ready state.

Process Transitions (2)

- Running → Waiting
  - When a process requests something for which it must
    wait:
    - a service that the OS is not ready to perform.
    - an access to a resource not yet available.
    - initiates I/O and must wait for the result.
    - waiting for a process to provide input.
- Waiting → Ready
  - When the event for which it was waiting occurs.

**Schedulers**

- Long-term scheduler --jobs
- Short-term scheduler --processes
- Mid-term scheduler -- swap some process

<img src="D:\Typora_CACHE\image-20220920104759743.png" alt="image-20220920104759743" style="zoom:50%;" />

**IPC： Inter-Process Communication**

- Cooperating processes require an inter-process communication (IPC) mechanism that will allow them to exchange data and information.
- There are two fundamental models of inter-process communication:
  - Shared memory
  - Message passing
    - message passing interfaces, mailboxes and message queues
    - sockets, STREAMS, pipes

## 3.2 Thread

Process switching is **EXPENSIVE**!

Concept of Process has two facets
A Process is:

- **A Unit of resource ownership** – process is allocated:
  - a virtual address space for the process image
  - control of some resources (files, I/O devices...)
- **A Unit of execution/dispatching** - process is an execution path through one or more programs (functions, code segments)
  - may be interleaved with other processes
  - execution state (Ready, Running, Blocked...) and dispatching priority

– The unit of resource ownership is referred to as a Task or (for historical reasons) also as a **Process**.
– The unit of dispatching is referred to a **Thread**.

进程内部支持cpu切换

# 4. CPU Scheduling

## 4.1 Basic Concept

**CPU-I/O Burst**

- Burst/Service time = total processor time needed in one CPU-I/O burst cycle.
- Jobs/Process with long CPU burst time are **CPU- bound jobs/processes** and are also referred to as “long jobs/processes”.
- Jobs with short CPU burst time are **IO-bound jobs/processes** and are also referred to as “short jobs/processes”.
- CPU-bound processes have longer CPU bursts than I/O-bound processes.

## 4.2 Scheduling Criteria & Metrics

**Parameters to evaluate the scheduling**

- CPU utilization [ **CPU 使用率** ] ( Efficiency )
  - keep the CPU as busy as possible (from 0% to 100%)
- Fairness: each process gets a “fair share” of the CPU
- Throughput [ **吞吐量** ]
  -  of processes that complete their execution per time unit
- Turnaround time [ **周转时间** ]
  - amount of time to execute a particular Process
    • i.e. execution time + waiting time
- Waiting time [ **等待时间** ]
  - amount of time a process has been waiting in the ready queue
- Response time [ **响应时间** ]
  - amount of time it takes from when a request was submitteduntil the first response is produced , not output (for time-sharing environment)

<img src="D:\Typora_CACHE\image-20220920114436576.png" alt="image-20220920114436576" style="zoom:33%;" /><img src="D:\Typora_CACHE\image-20220920114455784.png" alt="image-20220920114455784" style="zoom:33%;" /><img src="D:\Typora_CACHE\image-20220920114135290.png" alt="image-20220920114135290" style="zoom: 33%;" /><img src="D:\Typora_CACHE\image-20220920114145606.png" alt="image-20220920114145606" style="zoom:33%;" />

**Scheduling Algorithms**

- First Come First Serve Scheduling [ **先来先服务** ] ( Non-preemptive )
- Shortest Job First Scheduling [ **最短任务先服务** ]
  - SRTF (Shortest Remaining Time First Scheduling)/SRJF
- Priority Scheduling [ **优先权** ]
- Round-Robin Scheduling [ **时间片轮转** ]
- Multilevel Queue Scheduling [ 多层次队列 ]
  - Multilevel Feedback-Queue Scheduling [ 多层次反馈队列 ]
- Lottery Scheduling [ 抽彩 ]

## 4.3 Different Scheduling Algorithms

#### FCFS first Come First Serve Scheduling

先来先做

画甘特图

<img src="D:\Typora_CACHE\image-20220920115959494.png" alt="image-20220920115959494" style="zoom:50%;" />

#### Shortest Job First SJF

最短先做

<img src="D:\Typora_CACHE\image-20220920120543274.png" alt="image-20220920120543274" style="zoom:67%;" />

Determining length of next CPU Burst

<img src="D:\Typora_CACHE\image-20220920120952025.png" alt="image-20220920120952025" style="zoom:50%;" />

#### Shortest-Remaining-Job-First SRJF

剩的最少先做

<img src="D:\Typora_CACHE\image-20220920121656270.png" alt="image-20220920121656270" style="zoom:50%;" />

#### Priority

越小等级越高

**Preemptive 和 Non- preemptive的区别**：Preemptive在有新进程加入中也是一个调度时间

<img src="D:\Typora_CACHE\image-20220923104721902.png" alt="image-20220923104721902" style="zoom:50%;" />

Aging - 随等待时间更多，优先级提高

#### Round-Robin Scheduling

Preemtive, 将CPU服务轮换切片

<img src="D:\Typora_CACHE\image-20220923105956298.png" alt="image-20220923105956298" style="zoom: 50%;" />

- Short quantum: great response/interactivity but high overhead
  - Hopefully not too high if the dispatcher is fast enough
- Long quantum: poor response/interactivity, but low overhead
  - With a very long time quantum, RR Scheduling becomes FCFS Scheduling



- Advantages
  - Jobs get fair share of CPU
  - Shortest jobs finish relatively quickly
- Disadvantages
  - Poor average waiting time with similar job lengths
    - Example: 10 jobs each requiring 10 time slices
    - RR: All complete after about 100 time slices
    - FCFS performs better!
  - Performance depends on length of time-slice
    - If time-slice too short, pay overhead of context switch
    - If time-slice too long, degenerate to FCFS

#### Other

- Multilevel Queue
- Multilevel Feedback Queue
- Lottery Scheduling
- Highest Response Ratio Next

## 4.4 Algorithm Evaluation

### Deterministic modeling

### Simulation

# 5. Synchronization

## 5.1 Background & basic conecpts

Race condition 多线程冲突
critical section 临界区（共享数据）

Concurrent processes -> Deadlock
No controlled access -> Data Inconsistency

## 5.2 Problems & Solution for synchronization

### 5.2.1 Problems

#### Producer/Consumer Problem

<img src="D:\Typora_CACHE\image-20220927113338041.png" alt="image-20220927113338041" style="zoom:50%;" />

多Producer 和 Consumers 会覆盖

好的mutual exclusion还要考虑deadlock和starvation

**Rules for robust synchronization**

- Mutual exclusion should be guranteed
- Progress (deadlock-free)
- Bounded (starvation-free)

#### Software solution

**Peterson's algorithm** -2 processes is correct

<img src="D:\Typora_CACHE\image-20220927114553411.png" alt="image-20220927114553411" style="zoom: 67%;" />

#### Hardware solution

**Uniporcessor** could disable interrupts
**Modern machines** provide special atomic(non-interruptible) hardware instructions:

- Either test memory word and set value at once.
- Or swap contents of two memory words.

**Test and Set**

```c++
boolean TestAndSet(boolean *target) {
	boolean rv = *target;
	*target = TRUE;
	return rv;
}
boolean lock = FALSE;
do {
    while (TestAndSet(&lock)) ;
    critical section
    lock = FALSE;
    remainder section
}
```

**Swap**

```c++
void Swap(boolean *a, boolean *b) {
    boolean temp = *a;
    *a = *b;
    *b = temp;
}
boolean lock = false;
do {
    key = true; // key is a local variable
    while (key == true)
    Swap(lock,key);
    critical section
    lock = false;
    remainder section
} while (TRUE);
```

#### Machine Instructions for Mutual Exclusion

lock + Manager + Waiting Room

#### Operating System solutions

**Semapore（必考）**

<img src="D:\Typora_CACHE\image-20220927120705460.png" alt="image-20220927120705460" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220927121411080.png" alt="image-20220927121411080" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220927121424426.png" alt="image-20220927121424426" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220927121438292.png" alt="image-20220927121438292" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220927121447028.png" alt="image-20220927121447028" style="zoom: 67%;" />

**counting Semaphore**

<img src="D:\Typora_CACHE\image-20220927121715049.png" alt="image-20220927121715049" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220927121737068.png" alt="image-20220927121737068" style="zoom:50%;" />



### 5.2.2 Tasks

- Mutual exclusion
- deadlock-free
- starvation-free

### 5.2.3 Solutions

- Lock
- PV
- SEMAPHORE/MONITOR

# 6. Deadlock

## 6.1 Deadlock

### 6.1.1 Definition, Model

- A set of blocked processeseach holding some resources and waiting to acquire aresource held by anotherprocess in the set.
- None of the processes canproceed or back-off ( releaseresources it owns )

### 6.1.2 Four necessary conditions

- Mutual Exclusion [互斥]
- Hold-andWait [占有并等待]
- No preemption [非抢占]
- Circular Wait [循环等待]

## 6.2 Methods for Handling Deadlocks

- Providing enough resources

<img src="D:\Typora_CACHE\image-20221007102857597.png" alt="image-20221007102857597" style="zoom: 50%;" />

- Staying Safe
  - **Preventing** Deadlocks
    Do not allow one of the four conditions to occur 打破4个条件的成立(主要打破Hold and Wait和 Circular Wait)

    - Negating Hold and Wait 

      1. 进程运行之前把其所有条件都满足
      2. 每有一个新请求就把之前的释放然后再打包

    - Negating Circular Wait

      Order resource allocation资源顺序分配法<img src="D:\Typora_CACHE\image-20221007105648190.png" alt="image-20221007105648190" style="zoom:50%;" />

  - **Avoiding** Deadlocks
    每一次请求先判断
    considers the resources currently **available** , the resources currently **allocated** , and the **future (Needed)** requests and releases of each process, and decides whether the current request can be satisfied or must wait to avoid a possible future deadlock.
    <img src="D:\Typora_CACHE\image-20221007110404254.png" alt="image-20221007110404254" style="zoom:50%;" />
    available = total resource - max
    然后选need再一步步来得到序列

- Living Dangerously
  - Let the dead happen, then **detect** it and **recover** from it
    1. Process Termination
    2. Resource Preemption
  - **Ignore** the risks

# 7. Memory

MAPPING 1 - map files into main memory

- Basic: fundamental ideas nd old ways
- Advanced: so-called virtual memory

MAPPING 2 - map files into persistence storage medias(HDD)

- Basic: fundamental understanding about HDD space
- Advanced: File system
- Other: RAID, Spooling, etc.

## 7.1 Basic conecpts

- From Logic address to physical address
- MMU for relocation - address translation



- From program to process
  - Static & Dynamic linking
- Requirements of MM

## 7.2 Basic techniques of real memory management

### 7.2.1 Partitioning (Static & Dynamic)

partition and swapping 
static固定切，dynamic动态切

#### placement算法

**Equal-size partitions**:

1. If there is an available partition, a process can be loaded into that partition – because all partitions are of equal size, it does not matter which partition is used.
2. If all partitions are occupied by blocked processes, choose one process to swap out to make room for the new process.

Dynamic Partitioning Placement Algorithms

- Best-fit algorithm最佳匹配找最小可以实现的<img src="D:\Typora_CACHE\image-20221007120429571.png" alt="image-20221007120429571" style="zoom:50%;" />
- Worst-fit最差匹配与best-fit相对
- First-fit 首次匹配 最开始能够匹配的位置
- Next-fit 临近匹配 从上一次place的地方开始

Internal/External Fragmentation

1. Internal Fragmentation
   内碎片，分配在内存内部没有使用的内存
2. External Fragmentation

compaction 压缩

#### replacement算法

discuss in virtual memory

### 7.2.2 Overlay

once known as "Virtual Memory For 640K DOS"

<img src="D:\Typora_CACHE\image-20221007121731679.png" alt="image-20221007121731679" style="zoom:67%;" />

### 7.2.3 Dynamic Linking

dll

## 7.3 Old way for OS space

Knuth's Buddy System 二分法切割，产生内碎片

## 7.4 Paging

### 7.4.1 Basic paging

fixed partitioning but with smaller size

- It “partition/cut” the logical space of a process into pages [页]
- It “partition/cut” the physical space of MM into frames [帧]\

**page数据结构**

| Page | Frame |
| ---- | ----- |

OS should know the **mapping relationship** between pages of that process and frames of the MM

<img src="D:\Typora_CACHE\image-20221011113304752.png" alt="image-20221011113304752" style="zoom:50%;" />

<img src="D:\Typora_CACHE\image-20221011113321827.png" alt="image-20221011113321827" style="zoom:50%;" />

0 - > 2;
physical address = offset * pagesize

### 7.4.2 Paging-bsed  VM

#### Steps in handling a Page Fault

<img src="D:\Typora_CACHE\image-20221011113822824.png" alt="image-20221011113822824" style="zoom:67%;" />

#### Effective Access Time (EAT)

<img src="D:\Typora_CACHE\image-20221011113930056.png" alt="image-20221011113930056" style="zoom:50%;" />

p means page fault rate

<img src="D:\Typora_CACHE\image-20221011114146789.png" alt="image-20221011114146789" style="zoom:50%;" />

#### Impove

The solution could be derived from the EAT equation - Improve the access speed, and decrease the page fault

- keeping page table in a higher access speed media
  - Cache, and TLB(translation lookaside buffer)
- Prefeching the possible future accessed pages

### 7.4.3 Page replacement algorithms

<img src="D:\Typora_CACHE\image-20221011115236737.png" alt="image-20221011115236737" style="zoom:50%;" />

#### FIFO/FCFS

first in first out

<img src="D:\Typora_CACHE\image-20221011115311294.png" alt="image-20221011115311294" style="zoom:50%;" />

#### Optimal Page Replacement

Impossible to implement (need to know thefuture) but serves as a standard to compare with the other algorithms we shall study.

<img src="D:\Typora_CACHE\image-20221011115806798.png" alt="image-20221011115806798" style="zoom:50%;" />

#### LRU Policy

Replaces the page that has not been referenced for the longest time recently

<img src="D:\Typora_CACHE\image-20221011120029708.png" alt="image-20221011120029708" style="zoom:50%;" />

#### Clock Policy

- Replaces an old page, but not the oldest page
- Arranges physical pages in a circle
- Each page has a used bit
  - Set to 1 on reference
  - On page fault, sweep the clock hand
    - If the used bit == 1, set it to 0 and advance the hand
    - If the used bit == 0, pick the page for replacement

享受机会可以踢掉

<img src="D:\Typora_CACHE\image-20221011120838333.png" alt="image-20221011120838333" style="zoom:50%;" />

#### Does adding RAM always reduce misses?

Yes for LRU and MIN

- Memory content of Xpages 包含于 X + 1 pages

No for FIFO

- Due to modulo math
- Belady's anomaly: getting more page faults by increasing the memory size

#### Thrashing

If a process does not have “enough” pages, the page-fault rate is very high. This leads to:

- low CPU utilization.
- operating system thinks that it needs to increase the degree of multiprogramming.
- another process added to the system.
- This just increases the load on physical memory.

Thrashing = a process is busy swapping pages in and out.

## 7.5 Segmenting

### 7.5.1 Basic segmenting

**三种技术 on-demand paging, on-demand segmenting, hybird**

### 7.5.2 Segmentation-based VMM



## 7.6 Segment-page scheme(Hybrid)

now combines both paging and segmentation

先segmentation再paging

<img src="D:\Typora_CACHE\image-20221018114416398.png" alt="image-20221018114416398" style="zoom:50%;" />

# 8. IO

- Allocation and Address Translation
- Indexing data structure(Tree)

## 8.1 General structure to connect devices

### 8.1.1 IO devices - Categories

**按访问类型分**

1. Block devices 块设备
   e.g. hard disks
2. Character devices 字符设备
   - Character
   - Network

**按访问过程分**

1. Sequential Access Device
   e.g. 磁带
2. Direct Access Device

### 8.1.2 IO operations

#### Device controller

hardware that connects the device to the computer

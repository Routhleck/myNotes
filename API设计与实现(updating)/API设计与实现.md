[TOC]

# Introduction

陈长兵

50% 平时分
50% 大作业

## 课程教材

<img src="API设计与实现.assets/image-20230304172113208.png" alt="image-20230304172113208" style="zoom:50%;" />

# 绪论

## API研究方法

### API位置

- 调用软件库的方法
- 与操作系统交互
- 与数据库交互
- 使用第三方提供的服务
- 通过网络调用服务
- ...

### API作用

- 提供软件之前交互的方法
- 开放能力，提供服务的一种方式
- 支持模块化
- 隐藏细节

### 行业发展需要

- 企业协作
- 大规模集成
- 开放式创新

### API面临的挑战

- 现代软件开发模式，迭代&敏捷
- 灵活性 & 开放性
- 刚性 & 脆弱性

# API设计概论

## API是什么

- 应用程序编程接口，不同计算机程序之间的通信交互方式
- 软件接口的一种，向软件的其他模块提供服务
- 两种形态，API规格说明书和API实现

## 为什么需要API

**隔离**

> - 屏蔽底层细节
> - 维持一致连贯性
> - 安全保障

**简化**

> - 避免重复造轮子

**抽象**

> - 建立契约，等价性
> - 突出行为，掩盖特征
> - 高内聚低耦合

**共享**

> - 服务标准化、产品化
> - 建立合作关系
> - 价值链延伸

## API分类

基于服务对象

> 公有型API
> 私有型API
> 混合型API

基于技术类型

> gRPC API
> SOAP API
> RESTful API
> GraphQL API

## API服务模式

### ESB

**企业服务总线Enterprise Service Bus**是连接个应用系统之间的中央枢纽
基于SOA(面向资源的体系架构)的设计思路，主流

### 微服务

MicroServices，由一组完全独立的应用服务构成，独自独立部署和松耦合交互，共同完成特定的业务需求

## API经济

企业与企业之间通过API建立合作关系  1

# API设计规范

## API设计评估

- Operational 可行，可用
- Expressive 富有表象，表达能力强
- Simple 简单，简洁
- Predictable 可预测性

## 通用设计原则

- 简单原则
  - 声明直观清晰
  - 功能可见性
  - 简单易用程度
  - 单一职责
- 抽象原则
  - 按业务特征抽象实体
  - 最小信息，接口粒度
  - 恰当的抽象与具体
  - 更好的适用性、拓展性
- 兼容扩展原则
  - 开闭原则
  - 保证API的后向兼容
  - 拓展参数便利
- 统一原则
  - 统一的命名规范
  - 统一的入/出参规范
  - 统一的错误码规范
  - 统一的版本规范 
- 正交原则
  - 覆盖全业务流程
  - MECE原则，相互独立&完全穷尽
  - 高内聚低耦合
- 安全原则
  - 认证授权，访问控制
  - API自身保护
  - 传输数据保护

## API设计原则

API构成

> - 操作
> - 参数
> - 组织结构

### 命令规则

#### 好的命名特点

- Expressive
- Simple
- Predictable

命名的机制

> - 一致性
>   - 美式英语&英式英语
> - 语法
>   - 命令式动词
>   - 介词
>   - 复数
> - 词法
>   - 大小写
>   - 关键词

#### 四种命名方法

- 帕斯卡命名法
  首字母大写，单词无连接
- 驼峰命名法
  - 小驼峰法，除第一单词外首字母
  - 大驼峰法，帕斯卡
- 下划线命名法
- 匈牙利命名法
  `构成=属性+类型+对象描述`

#### 其他考虑因素

- 上下文Context
  - 上下文携带信息，影响名字的含义
  - 限定含义，或赋予特有含义
- 数据类型和单位
  - 数据没有单位会引起混乱
  - 引入丰富的数据类型

### 数据类型和默认值

- 数据类型是每个编程语言的重要组成部分
- 动态类型，Dynamic Typing
- 序列化 & 反序列化， 信息丢失
- 缺失与空值

#### 布尔类型

- 一定应用场景
- 二值表达力有限，可能有更好的方案
- 避免double negative（双重否定）

#### 数值类型

- 存在算数计算诉求场景
- 不适用于纯数值类标识符
- 边界
- 默认值
- 序列化

#### 字符类型

- 最通用的数据类型
- 编码，byte & char & Character
- 边界
- 序列化
  标准等级与兼容等价，组合和独立字符两个维度

#### 枚举类型

Name(字符) + Value(数值)

优势：校验，压缩
不足：依赖码表，变更同步

**API场景传输时，优先字符类型**

#### 列表类型

- 基本类型的集合，也可以是其他列表或Map类型
- 原子性
- 边界
- 默认值

#### Map类型

- 边界
- 默认值

### 资源范围和层级

#### 资源布局

是一种实体关系模型，实体与实体之间的关系

- 关系的种类
  - 引用关系
  - Many-to-One关系
  - 自引用关系
  - 层级关系
- ER图

**如何选择正确的关系**

> - 是否需要建立一个关系
>   - 建立关系是有代价的，性能变差，维护复杂
>   - 关系也是有价值的，比如社交网络
>   - 新增关系 一定与 某个重要的业务需求挂钩
> - 使用引用reference还是内嵌in-line
>   - 引用方式：通过指针找到真实对象
>   - 内嵌方式：存储对象的全部数据
>   - 差异：交互次数，传输数据大小
>   - 考虑因素；具体场景具体看，需求意图，底层存储方式
> - 层级
>   - 层级关系or引用关系
>   - 层级关系特点：操作的级联性

# API设计模式

## 标准方法

标准方法，直观明义

仍有大量细节隐藏和丢失

| API 标准方法 | 描述                 |
| ------------ | -------------------- |
| GET          | 获取资源或数据       |
| POST         | 创建新资源或提交数据 |
| PUT          | 更新或替换资源       |
| PATCH        | 更新资源的部分内容   |
| DELETE       | 删除资源             |

一般而言都要实现，除非有明确的的合理的不能实现的理由

### 幂等性和副作用

- 幂等性 idempotence
  - 多次(同一个)操作，结果是一致的
  - 分布式场景，重复请求，应用超时或失败重试，网络抖动
  - 数据丢失，数据损坏，数据不一致
- 副作用 side-effect
  - 非预期的影响，没有额外的行为
  - 新建邮件，涉及邮件发送逻辑

---

- GET
  - 幂等性
  - 没有副作用
- List
  - 根据查询条件返回符合条件的资源列表
  - 资源列表，可能是资源集合的一个子集，也可能属于某个其他资源
  - 访问控制
  - 结果数量
  - 排序
  - 过滤
- Create
  - 建议使用POST方法
  - 标识符
  - 一致性
- Update
  - 建议使用PATCH方法，部分更新
  - 更新资源的信息
  - 特殊的更新：变更资源的状态
- Delete
  - 建议使用DELETE方法
  - 幂等性
- Replace
  - 建议使用PUT方法
  - 强Schema场景，整体替换，没有中间状态
  - 能否用于创建新资源？
  - 能否指定标识符？

### Trade-off

- 放弃一些灵活性
- 完全自定义的RPC风格API
- 规范，一致，成本
- 不绝对，二八原则，标准方法解决80%的问题

## 定制方式(自定义方法)

因为标准方法不是万能的

**概述**

> - 不满足标准方法上的严格约束
> - 没有约束，完全自由发挥
> - 杂乱发展，将难以维护
> - 在整个API设计中，仍需保持某一种一致性的约束

### 方法命名

- 与标准方法相同命名习惯
- 构成格式：动词 + 名词
- 其他约束也要遵循：介词，复数等

### 副作用

- 与标准方法最大的差异
- 标准方法的强约束：没有副作用，不涉及额外的操作
- 如发送邮件、触发底层操作、更新多个资源

### 方法放在哪里

资源还是集合？

### Stateless场景

- 即时处理请求后返回结果，不涉及其他数据的获取或存储
- FaaS函数即服务，业务逻辑
- 完全无状态，上下文？

### Trade-off

- 与REST设计原则会有冲突
- 在简洁的资源体系下，扩展非标准交互的能力
- 经常被误用或过度使用

## 部分更新与检索

- 部分检索
  - 边缘设备处理能力
  - 网络带宽
- 部分更新
  - 数据一致性
  - 数据丢失
  - 细粒度的使用场景

---

一种简洁的实现方式，使用字段掩码field mask

### 如何传输

对服务端的server有不同方法

- HTTP协议构成
  - 请求串，请求体，Header
  - GET没有请求体
  - PATCH请求体应该只包含资源部分
- 不同HttpServer服务端，对请求串中数组的处理方式存在差异

### Map或嵌套类型

- 请求的参数不是平铺的，多层数据结构

- fieldmask数据格式约定

  > - 使用逗点连接不同的部分
  > - 使用星号标识某个嵌套信息中的所有字段
  > - Map Key是字符类型
  > - Map Key中特殊字符使用反引号字符转义
  > - Map Key中反引号字符使用两个反引号转义

### 列表类型

- 可以与Map类型类似

### 默认值

- 部分检索
  - 与标准Get方法默认一致，需要列出所有字段
  - 接口升级，增加字段，客户端需要更新
  - 引入星号，代表所有字段
- 部分更新
  - 默认所有字段
  - 基于输入数据，自动推断

### 隐式field maks

- 标准update方法使用PATCH
- 根据请求数据推断field mask
  - 提供了哪些字段，就更新哪些字段
  - 某个字段值为null，如何处理

### 更新动态数据结构

- 三种情况：有值、null值、key缺失
- 删除某个key
  - 标准replace方法
  - PATCH方法，在field mask指定字段，在请求体不存在
  - `fieldMask=settings.test&fieldMask=title`
  - `{"title":"new title"}`

### 无效字段

- 静态数据结构，检索或更新不存在的字段
- 防御性编码策略
  - 抛出异常，返回错误
- 一致按undefined处理

### Trade-off

- 应用场景约束
  - 最小化非必要数据的从传输
  - 精细化数据修改
- 为保持一致性，所有接口通用支持

## 批操作

- 是否需要完全成熟的通用事务设计模型
  - 支持必要原子操作  
- 在标准方法前期加上Batch
  - BatchDeleteMessages
  - 方法类似，但实现会有差异

- HTTP方法 类似自定义方法，优先使用POST 或类似标准方法
- 要考虑如何保持原子性
  - 批量查询，如果一个字段被删除了，是否整个都失败
  - 能否在多个父资源的进行操作？

### 原子性

- 定义：表示一组操作是原子性的，他们之间不可分割。整体操作只能全部成功或全部失败，没有中间状态。
- 设计考量：通常，原子性是批处理的核心诉求（优先）。但也要考虑复杂度和实现成本,此时可允许部分失败。
- 设计目标：批处理模式下的操作都要保持原子性。

- 操作位置
  - 父资源   `/chatRooms/*:batchUpdateMessage`
  - 资源集合  `/chatRooms/*/messages:batchUpdate`

### 结果顺序

- 结果的顺序，与请求的顺序一致
- 如果返回数据未保持顺序，要分析结果与请求的对应关系 

### 常用字段

两种策略

> 请求对象数组，通用性好，如针对不同父对象的操作
> 主键字段数组，更简洁，如获取或删除一组资源

两种策略混用，要注意，可能APIServer拒绝执行

### 跨父资源操作

使用对象数组，比共用更优
每个请求对象，单独指定父资源

### BatchGet操作

- 除了顶层资源，一般都有一个parent指示字段

- 跨父资源，可使用通配符，比如连接字段

- 跨父资源有时不合理

  > 分布式系统中，不同父资源可能存储在不同位置
  > 只要一个失败，则都会失败。可能需要更宽松的保证

- 部分检索 统一的fieldmask

- 批操作一般不实现分页，而是限制返回数量

### BatchDelete操作

- 使用主键字段数组，使用POST方法
- 除了顶层资源，一般都有一个parent指示字段
- 跨父资源，使用通配符，同时要充分考虑合理性和可行性
- 原子性，删除所有给定的所有资源，或整体失败

### BatchCreate操作

- 请求使用对象数组 
- 除了顶层资源，一般都有一个parent指示字段 
- 预先是没有主键字段的，这个是API Server端创建的 
- 请求与结果的顺序一致性

### BatchUpdate操作

- 与BatchCreate基本相似
- 差异，部分更新 部分更新字段需要，每个资源可以不同 fieldmash针对单个的资源
- 使用POST方法 与标准Update方法的PATCH不同

### Trade-offs

- 首先把原子性放在首位，即使实现不方便
- 一致性
  - 简单性优于一致性
  - 请求有时是主键字段，有些是对象

## 分页

- 资源的大小和数量，量级非常大。通过单次请求和响应获取数据，可能会非常慢或不可行
- 如果将数据切割成可管理的分区，消费者可轻易获取单个分区

---

- 每次**返回一页中的记录**，同时**返回下一次消费的指针位置**
- 引入**光标**的思想
- 我需要一页（获取新的信息或咨询） & 我需要第*页（随机访问 有先验知识）

### page size

- 默认值 视资源大小而定 一般十条
- 上界和下界
  负数，和超过一定数值，可以直接拒绝

### page tokens

- 如何表示终止 返回一页数据不满 或 返回空页
- 一致性
  - 新增删除数据 下一页返回结果与当前页相同
  - 依赖使用的存储系统
  - 避免使用绝对偏移量 使用相对偏移量

### total count

- 友好的用户体验
- 总数非常大时 操作困难
- 不提供准确值 只提供预估值 耗时更短

### 单一大资源分页 

page token，Max bytes

## 长耗时操作

- 复杂操作，处理大数据量。占用服务器资源与网络资源。系统需要一直等待。
- 用于即时操作的设计方法在此时不一定能适用
- 需要能够支持异步的交互

---

- 类似Future或Promise机制
  - 启动任务，不阻塞，立即返回一个Promise对象
  - 在Promise对象上等待，或注册回调函数
- 与这种机制还有一些差异
  - 资源需要**持久化**
  - 需要一些**元数据** 如进度开始或完成的时间 当前执行的动作
  - 需要一种**发现和管理LROs**的方法

> 两个部分：定义Operation资源 & 发现和管理LROs的API接口

### LRO(Large Receive Offload)资源

- 作为一种资源，能够交互
- **最终返回结果**
  - 最终返回结果
  - 要考虑有错误发生或者未成功完成
  - 标识成功完成，没有其他结果信息
  - 所有结果字段是可选的，是正常的结果类型（泛型），或者操作错误类型

- **状态标识**
  - done标识字段，是否已结束
  - pending（堵塞），resolved（恢复），rejected（拒绝）

- **元数据信息**
  - 在结束前，提供一些任务的动态信息
  - 进度信息，预估剩余时间
- *最终返回结果，和元数据信息，有时都是非必须的*

### LRO 资源的层级 

集中式顶层资源集合

### LRO 解析

- Polling，轮训，`GetOperation`
  客户端，检查频次，停止检查
  不能立即知道结果
- Waiting，等待，`WaitOperation`
  一直维持链接，一旦结束，立即知道结果
  服务端的轮训，链接丢失，可以再使用轮训方式

### 错误处理

- Http请求，错误处理使用 **http错误码**
- LRO不能使用
  - 返回的http错误码，不能区分是操作的结果，还是`GetOperation`的处理结果
  - **http错误码仅用来表示资源操作的处理结果**
- LRO的处理结果，放在最终返回结果字段`OperationError`
  - 错误码&错误信息
  - 除错误类型，额外信息，最好结构化，机器可识别的方式

### 进度监控

`MetaData`来表达
	任务开始时间，任务进度
	预估剩余时间，已处理字节数量

应用
每轮轮巡时，获取进度

### 取消操作

错误数据创建需要取消

自定义方法，`CancelOperation`

- 需要等待完成，阻塞
- 中间结果要清理，回到初始状态
- 有些无法清理的，反馈，元数据信息
- 不是所有操作都可取消

### 暂停和恢复操作

只有合理和可行的场景可暂停和恢复

自定义方法，`PauseOperation, ResumeOperation`
元数据新增一个布尔字段, `paused`

### 持久化

持久化策略

- 其他常规资源保持一致
- 滚动窗口，比如30天有效期，有效期外，会被删除
- 其他策略，操作对应的资源删除了，二级有效期，归档，删除归档

### Trade-offs

最简单的办法就是等待

- 可能不能很好适应分布式系统
- 一个微服务初始化任务，另一个监控进度
- 监控进度，意味着一直阻塞等待
- 如果链接短了，就可能会丧失恢复的能力

## 可重复运行作业

场景

> 虽然有异步调用的API，但仍需客户端触发执行
> 异步执行，但每次调用需要提供所有相关配置
> 按需执行模型，混合两种权限：执行方法的能力，和配置参数的能力
> 按某种循环计划的方式自动执行

**job概念**

> 特殊的资源类型
> 配置过程
> 执行过程
>
> 一次配置多次执行，划分两个方法更便于控制权限，在调度系统中，只调用执行接口即可，不需要关注大量繁琐的配置

### 基本属性

- 标识符
- 所属资源
- 配置信息

### 标准方法

`Create, Get, Delete, List`

同步并立即返回
并非所有方法都要支持，比如Job是不可变更的，可忽略update方法

### 自定义方法run

入参只有`Job Id`，返回LRO对象

### Execution执行资源

属于特定的Job类型下

Job & Execution & Operation

### Trade-offs

多种解决方案

- 针对权限问题，可以设计高级的权限系统
  - API方法 + 方法参数都进行检查控制
  - 缺点，实现逻辑复杂
- 执行计划，可以只保持Operation资源
  - 作为输出的引用
  - 缺点，过滤Operation资源获取Job关注的信息

## 导入导出

有一些序列化数据需要导入

### 自定义方法

`import & export`, 返回类型是LRO

### 存储系统交互

单个schema，保存所有配置
使用接口，针对不同存储系统特定实现

**针对import和export不共用，`DataSource & DataDestination`**

### 资源与二进制的转化

序列与反序列化

**配置`InputConfig, OutputConfig`**

### 一致性

导出数据时，首先要保障导出所有或满足条件的所有数据

导出时，资源变更怎么办

> - 依赖底层存储系统的快照和事务能力，读取特定时间点的所有数据(数据量大，不容易支持)
> - 接受现实，尽最大的可能是精确的数据
> - 导出期间，禁止变更

导出数据，与备份数据，差异

> - 备份是一种快照
> - 导出是通过数据检索的方式，转义到外部存储设备

### 主键与冲突

> 导入数据主键已经存在
> 导出后再次导入，但不同的父资源
> 有些API不允许用户指定标识符

导入&导出不能直接用于备份和恢复
**需要更严苛的数据检查，备份时需要一致性快照，导入时是完整的替换**

### 处理关联资源

针对父资源，不一定包含所有子资源

**与备份和恢复，需要再次划清界限**

### 失败和重试

两种问题原因:
API服务的问题
存储系统的问题

**导出失败**

> 每次导出独立，重试安全
> 每次导出的执行可能不同
> 存储系统的话如磁盘空间不足

**导入失败**

> 不能像导出一样，无法简单的直接重试
> 因为数据校验，而不是网络问题，再次重试还是有问题
> 即使是偶发性问题，也不能直接重试，前一次导入可能创建新资源，数据重复

**导入失败处置策略**

> 在一个事务执行导入操作(不是所有存储系统都支持)
> 同一事务导入大批量数据也不可行
>
> 另一办法是支持请求去重
> 不一定是资源标识符，可以是每条记录的导入请求id
> 导出时，可配置是否序列化到输出数据中

### Trade-offs

**这个模式定位非常窄和具体**
只是作为API和外部存储系统的中间桥梁，替代了编写应用程序实现数据转移

**这导致有两个缺点**
只能用于转移一种资源类型，否则就不是简单的纯粹的一种数据转移，而是包含业务逻辑
容易与数据备份和恢复功能混淆，没有一致性保障

# API安全



# API技术实现
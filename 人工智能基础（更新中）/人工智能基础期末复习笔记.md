<img src="D:\Typora_CACHE\image-20220602110441612.png" alt="image-20220602110441612" style="zoom:67%;" />

# 1.人工智能概述

## 1.人工智能的萌芽与诞生

### 1.人工智能的萌芽

**1936** 图灵提出**图灵机** 奠定理论基础
**1940-1942** 爱荷华州立大学J.V.Atanasoff和C.Berry装配**第一台电子计算机** 命名为ABC
**1943** 美国神经生理学家沃伦·麦卡洛奇(W.McCulloch)与数理逻辑学家沃尔特·皮茨 (W.Pitts) 提出了 **人工神经元**的概念。建立了第一个 **神经网络模型**(M-P模型)
**1950** 图灵提出“图灵测试” **2000** 图灵预言能够蒙骗30%的人 **2014** 尤金欺骗30%的测试者
**1966** ACM设立图灵奖

### 2.人工智能的诞生

**1956** “达特茅斯夏季人工智能研究计划”会议，是被广泛公认的 **人工智能诞生地**。 麦卡锡被称为**人工智能之父**

马文 文• 明斯基（Marvin Lee Minsky）1927-2016
**人工智能之父**
**1975** 首创**框架理论** （知识表示的一种方法）
**1969** 首位获得 **图灵奖** 的人工智能学者

约翰 翰• 麦卡锡（John McCarthy）
1927-2011
• 人工智能之父
• **首次提出 “人工智能”的概念**
• LISP 语言的发明者
• Won **Turing Award** in **1971**

赫伯特• 西蒙（Herbert A. Simon ，1916-2001）
 符号主义学派的创始人
 爱好广泛的全能科学家
 **1975**年,与他的博士Newell共同获得图灵奖Ph.D student.
 **1978**年，获得诺贝尔经济学奖
 中国科学院外籍院士

艾伦 伦• 纽厄尔（Allen Newell）（1927 — 1992 ）
 符号主义学派的创始人之一
 西蒙的学生与同事
 1975年与西蒙同获图灵奖

2019年3月27日，ACM宣布，深度学习的三位创造者Yoshua Bengio（深度学习鼻祖）, Yann LeCun（卷积神经网络之父）, 以及Geoffrey Hinton 获得了2018 年的图灵奖。

## 2.人工智能的定义

人工智能 是研究开发能够模拟、延伸和扩展人类智能的理论、方法 、技术及应用系统的一门新的技术科学 。

 **弱人工智能** ( weak artificial intelligence)是能够完成某一特定领域中某种特定具体任务的人工智能。
 **强人工智能** ( strong artificial intelligence)也称为 通用人工智能 ，是具备与人类同等智慧，或超越人类的人工智能，能表现正常人类所具有的所有智能行为。

## 3.人工智能的发展简史

（1） 1930s-1956：AI的孕育期
（2） 1956年：人工智能诞生
（3 ）1956- 1960s中期： 通用方法 时代 （黄金期）
（4） 1960 年代中期-1970 年代初 ： 第一个 寒冬 期
（5） 1970 年代初-1980 年代末 ： 专家系统与知识工程时代 （繁荣期）
（6） 1980 年代末-1997 ： 第二个寒冬期
（7） 1997-2011：AI的复苏期
（8） 2012至今：AI的蓬勃发展期

<img src="D:\Typora_CACHE\image-20220602142116413.png" alt="image-20220602142116413" style="zoom:67%;" />

## 4.人工智能的流派

符号主义和连接主义研究流派，在 人工智能发展的 的60-70 年中，此消彼长，轮流占上风 。目前， **连接主义是业界关注的焦点**。

### 1.符号主义

符号 主义是一种基于逻辑推理的智能模拟方法，源于数学逻辑。它认为：人工智能本质是 知识符号化，只要将世界知识转换为某种符号系统，智能机器就可以根据该符号体系，解决真实世界的问题。其 成果有 ：机器定理证明、专家系统、启发式搜索算法

### 2.连接主义

连接主义源于仿生学，特别是人脑模型的研究。它认为，大脑是智能产生的根源，因此实现人工智能应该研究大脑的结构、信息处理机制、运行方式，然后在机器上 模拟人类大脑，实现人工智能。这就是现在阶段主流的人工神经网络方法。

### 3.行为主义

行为主义(actionism),又称为进化主义(evolutionism)或控制论学派(cyberneticsism) 。该学派的理论基础是控制论，其核心思想是基于控制论构建感知-动作型控制系统。

 行为主义学派认为：智能行为是在现实世界中与**周围环境交互**而获得并表现出来的，人工智能可以像人类的智能一样逐步进化，所以称为进化主义。
 行为主义还认为智能取决于感知和动作，无需知识、表示和推理，只需要表现出智能行为即可， **强化学习**就属于这一流派。

## 5.人工智能研究的基本内容

### 1.知识表示

 符号 表示法：用各种包含具体含义的符号，以各种不同的方式和顺序组合起来表示知识的一类方法。例如，一阶逻辑、 产生式等。
 连接机制 表示法：把各种物理对象以不同的方式及顺序连接起来，并在其间互相传递及加工各种包含具体意义的信息，以此来表示相关的概念及知识。例如，神经网络等。

### 2.机器感知

是使计算机系统模拟人类通过其感官与周围世界联系的方式具有解释和理解外部信息的能力。以机器 视觉与机器 听觉为主。

### 3.机器思维

又称为计算机思维（Computer Thinking），就是研究如何使机器或计算机能像人类一样进行思维活动，自主处理通过感知获得的外部信息和机器内部的各种工作信息，更通俗地说，就是要研制会自主思考的机器 。

### 4.机器学习

 人类是通过学习具有智能的，计算机若要具有真正的智能，也必须像人类那样学习。
 机器学习：研究如何使计算机具有类似于人的学习能力，使它能通过学习自动地获取知识。

### 5.机器行为

 指机器具有人工智能的行为，或者说，机器能模拟、延伸与扩展人的行为。

## 6.人工智能的主要研究领域

1. 深度 学习
2. 自然语言理解
3. 计算机视觉
4. 智能机器人
5. 自动程序设计
6. 数据挖掘与知识发现

# 2.知识表示与知识图谱

## 1.知识的概述

知识是智能的基础。

### 1.知识的定义

至今，对于知识还没有一个统一而明确的界定。比较有代表性的定义如下：
（1） 费根鲍姆（Feigenbaum）说：知识是经过裁剪塑造、解释、选择和转换了的信息。
（2） 伯恩斯坦（Bernstein）说：知识由特定领域的描述、关系和过程组成。
（3） 海叶斯—罗斯（Heyes-Roth）说：知识=事实+信念+启发式。
总之， **知识**是人类在长期的生活、社会实践及科学实验中经过总结、提升与凝练的对客观世界（包括人类自身）的认识和经验，也包括对事实和信息的描述或在教育和实践中获得的技能。

### 2.知识的特性

相对正确性 与 不确定性

### 3.知识的分类

（1） **陈述性知识**（descriptive knowledge，或描述性知识），是表示对象及概念的特征及其相互关系的知识，以及问题求解状况的知识，它描述的是“做什么”的知识，即一般性事实，故也称为 事实性 知识 ，是 显式表示的。如：“煤是黑色的”，“北京是中国的首都”。事实性知识是用符号代表概念、命题与原理，是相对 静态的。
（2） **过程性知识** （procedural knowledge，或程序性知识） 表示的是问题求解控制策略，描述的是“如何做”的知识，即做某件事的过程。过程式知识一般利用算法进行描述， 用一段计算机程序来实现。这种知识是 隐含在程序中的，是相对 动态的。

## 2.知识表示的方法

知识表示 （knowledge representation） 就是将人类知识符号化并输入给计算机的过程和方法。

知识表示可以是一种 符号描述 、是 某种约定，也可以是某种 数据结构。
知识表示方法的分类与知识的分类是紧密相关的。知识分为两类：陈述性知识和过程性知识。
从知识的运用角度，可将知识表示方法粗略地分为以下两大类：

### 1.陈述式知识表示

用于描述陈述性知识，即描述“是什么”，而不用描述“怎么做”。 静态描述 显式表达

知识的表示和知识的运用一般是分开的

**优点**：

- **可理解性好**，表示形式简洁、清晰、易懂；
- **易于修改**，一个小的改变不会影响全局，不会引起大的改变；
- **可独立使用**，这种知识表示出来后，可用于不同目的；
- **易于扩充**，这种知识模块性好，扩充后对原有模块没有影响。

**缺点**：将知识与控制分开，求解问题的执行效率低。

### 2.过程式知识表示

过程就是事实的一些客观规律。过程式知识表示方法表达的是如何求解问题， **知识的表示形式就是程序**。

动态过程 隐式表达 在采用过程式知识表示方法描述知识的系统中， 知识的表示和知识的运用一般是不分开的，表示就寓于运用之中，它适合于知识表示与求解结合非常紧密的这一类问题。

优点：

- **执行效率高。**
  知识是用程序表示的，知识库与推理机完全合为一体，即知识与控制融合在一起。

缺点：

- **可理解性较差**，采用隐式表达形式，形式复杂、不直观，不易理解；
- **不易于扩充**，这种知识模块性差，难以添加新知识和扩充新的功能；
- **不易于修改**，想要修改现有知识而不影响其他知识的完整性，比较困难，容易出错。

连接主义只有神经网络

## 3.产生式表示法

“ 产生式（production）” 意思是能够根据已知条件产生新知识的式子。
这些式子往往以规则的形式描述知识，因此 产生式也称作“ 产生式规则”；
产生式表示法也称为 产生式规则表示 法。
它属于 **符号主义流派**的知识表示方法。

产生式表示方法通常用于表示 事实、 规则以及它们的 不确定性度量。
有许多知识本身就是事实描述性的， 事实可看成是一个对象的某属性的值或是多个对象之间关系的陈述句。
事实又分为**确定性事实**和 **不确定性事实**。

### 1.产生式

#### 1.确定性事实的产生式表示

确定性事实一般采用三元组表示，有两种形式：
 属性型事实知识：描述一个对象的某种属性，形式为 (对象，属性，值)
	如，“李丽的年龄是30岁”表示为 （李丽，年龄，30）
 关系型事实知识：描述两个对象之间的关系，形式为（对象1，对象2，关系）
	如，“李丽和王军是朋友”表示为（李丽，王军，朋友），此处，关系就是一个词，而不是数字。

#### 2.不确定事实的产生式表示

不确定性事实可以用一个不确定度量值（∈（0，1））表示其不确定程度，即置信度或可信度，一般采用四元组表示，也有两种形式：
 属性 型事实知识：描述一个对象的某种属性，形式为（对象，属性，值，置信度）
	如，“李丽的年龄很可能是30岁”表示为 （李丽，年龄，30，0.85），此处，置信度0.85表示“很可能”。
 关系型 事实知识：描述两个对象之间的关系，形式为（对象1，对象2，关系，置信度）
	例如，“李丽和王军不太可能是朋友”表示为（李丽，王军，朋友，0.15），此处，置信度0.15表示“不太可能”。

除了描述事实，产生式还可以描述规则，规则用于表示有关问题领域中事物之间的因果关系，在产生式表示法中**将规则作为知识的单位**。
规则可分为 **确定性规则**和 **不确定性规则**

#### 3.确定性规则的产生式表示

确定性规则的产生式表示的基本形式是
IF condition THEN action 或者 condition → action
其中condition称为 条件或 前件或 前提，action 称为 动作或 后件或 结论。
语义含义是：如果condition所表示的条件被满足，则可得到action所表示的结论或者执行action所表示的动作，即action是由condition来触发的。例如，有如下规则：

- 如果下雨，则出门带伞；
- 小刚很聪明∧小刚学习很勤奋→小刚的学习成绩很好；

#### 4.不确定性规则的产生式表示

若规则是不确定的，则需增加置信度的度量值。不确定性规则的产生式表示的基本形式是
IF condition THEN action （置信度）或者 condition → action (置信度)
例如，有一条产生式为： 发烧呕吐∧出现黄疸→肝炎（0.7）

### 2.产生式系统

一个产生式系统的基本结构由 **规则库**（production rules base）、 **综合数据库**（global
database）和 **控制系统** （control system）三部分组成.
**综合数据库**和**规则库**共同组成了 **知识库**；
**控制系统**又称为 **推理机**，包括 **控制程序**和 **推理程序**两部分。

<img src="D:\Typora_CACHE\image-20220602192930818.png" alt="image-20220602192930818" style="zoom:67%;" />

1. **综合数据库**
综合数据库又称为 **事实库**，是产生式系统所使用的主要数据结构，其中存放问题的初始状态、输入的已知事实、推理过程中得到的中间结果及最终结论等信息。
2. **规则库**
在产生式系统中，用产生式规则描述与所求解问题相关的领域知识，规则库就是所有这些 **产生式规则的集合**，其中包含了将问题从初始状态转换成目标状态所需的所有规则。
3. **推理机**
推理机是一组 **规则解释程序**，包括控制策略和推理方式。推理机协同规则库与综合数据库，控制问题求解过程的推理路线，负责整个产生式系统的运行，实现对问题的求解。

### 3.产生式表示法的特点

产生式表示法的 **主要优点**
(1)格式单一，计算简单。
(2)模块性，便于知识的操作和管理。
(3)形式自然，便于理解、推理和解释。
(4)表达较全面，应用广泛。

产生式表示法的 **主要缺点**
(1)求解效率不高。
(2)无法表示具有结构关系的知识。

## 4.状态空间表示法

**状态空间** （state space）表示法是人工智能中最基本的形式化方法，是其他形式化方法和问题求解技术的出发点。
**状态**（state）就是用来描述在问题求解过程中某一个时刻进展情况等**陈述性知识**的一组变量或数组，是某种结构的符号或数据。

状态（state）是一组变量q0，q1，q2，…，qn的有序集合，其形式如下： Q={ q0，q1，q2，…，qn }其中，每个元素qi 称为一个状态变量。
状态的表示还可以根据具体应用，采取合适的数据结构，如符号、字符串、多维数组、树和图等。

**操作**也称为 **运算**，用来表示引起状态变化的 **过程性知识**的一组关系或函数，它会引起状态中的某些分量发生改变，从而使问题由一个具体状态转换到另一个具体状态。
操作可以是一个动作（如棋子的移动）、过程、规则、数学算子等，表示状态之间存在的关系。
用于表示操作的符号，称为 **操作符**（operator）或 **操作算子**、 **运算符**。
**状态空间**是采用状态变量和操作符号表示系统或问题的有关知识的符号体系。

问题的状态空间是一个表示该问题全部可能状态及其相互关系的集合，
常用一个 **四元组**（S,O,S0 ,G）来表示，其中:

- S 为问题的状态集合；
- O 为操作符的集合；
- S0 是问题的初始状态，是S的一个非空真子集，即S 0 ⊂ S；
- G 为问题的目标状态，它既可以是若干具体状态，也可以是满足某些性质的路径信息描述，G ⊂ S。

状态空间通常用 **有向图**来表示，其中， **结点**表示问题的**状态**，结点之间的 **有向边**表示引起状态变换的**操作**，有时边上还赋有**权值**，表示变换所需的**代价**。
在状态空间中，求解一个问题就是从初始状态出发，不断运用可使用的操作，在满足约束的条件下达到目标状态。
**问题的解**可能是图中的一个状态，也可能是从初始状态到某个目标状态的一条路径，还可能是达到目标所花费的代价。
下图中， **问题的解**便是一条从结点 S 0 到结点 G 的路径，它是一个从初始状态到目标状态的有限的操作算子序列{O 1 ，O 2 ，…O k }，称为**求解路径**。**问题的解往往并不唯一**。

<img src="D:\Typora_CACHE\image-20220602194732236.png" alt="image-20220602194732236" style="zoom:67%;" />

#### 例2.1 八数码问题

<img src="D:\Typora_CACHE\image-20220602195457822.png" alt="image-20220602195457822" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220602195512403.png" alt="image-20220602195512403" style="zoom:67%;" />

#### 例2.2 旅行商问题

<img src="D:\Typora_CACHE\image-20220602200211355.png" alt="image-20220602200211355" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220602200221492.png" alt="image-20220602200221492" style="zoom:67%;" />

对于大规模的问题，例如旅行商问题中有100个城市，要在有限时间内画出其全部状态空间图，是不可能的。
对于 **简单问题**，可以采用有向图 **直接画出状态空间**。
对于大多数 **复杂的问题**，是根本 **无法完全画出其状态空间**的，此时只需清晰定义状态变换的方式即可，也可以建模。

## 5.知识图谱

**符号主义知识表示方法**经过历代人工智能科研人员的不断完善， **演变为知识图谱**这一符合互联网时代新需求的知识表示方法。
知识图谱是一种用图结构来描述知识及其之间关联关系的技术方法，旨在利用知识工程理论建立大规模知识资源，**是语义Web技术在互联网大数据时代的成功应用**。
**知识图谱**（Knowledge Graph）又称为 **科学知识图谱**，知识图谱这一名词是谷歌公司于2012年5月17日首先提出的，其 **初衷**是为了提高搜索引擎的能力，改善用户的搜索质量以及搜索体验， **目标**是构建一个可提供智能搜索服务的大型知识库。

### 1.知识图谱的定义

至今，知识图谱尚未有一个统一的定义。本质上，知识图谱是一种揭示客观世界中存在的**实体**（Entity）、 **概念**（concept）及其之间**各种关系**的大规模语义网络，它以图结构表示知识，可理解为是一种描述语义知识的形式化框架， 知识图谱就是这样一类知识表示和应用技术的总称。
知识图谱是一种**图结构的语义知识库**，组成单位是**实体**、**属性**和 **关系**。

- **结点**表示实体（entity）或概念（concept）或属性值(attribute value)
- 结点之间的 **边**（edge）表示属性（attribute）或关系（relationship）
- **边的方向**表示关系的方向
- **边上的标记**表示属性名称或关系类型。

####  1.概念

也称为 **类别**（Type）、 **类**（Category或Class）， 是某一领域内具有相同性质的对象构成的集合，如在描述大学领域的知识图谱中，教师、学生和课程是必要的概念，而体育比赛领域中的概念则可能包括运动员、裁判员、教练、奖项等。概念主要用于表示集合、类别、对象类型、事物的种类。

#### 2.实体

有时也称为 **实例**(instance)或 **对象**（Object），实体是知识图谱中的最基本元素，是概念中的具体元素，它是 **独立存在且可相互区别的客观事物**。例如，“C罗”是“足球运动员”这一概念的一个实例，“金球奖”是“奖项”这一概念的一个实例。

#### 3.属性

**描述实体或概念的特性或 性质**。 **属性值** 可能是一个 **实体** 、一个 **字符串** 或一个 **数值**。例如运动员的属性“国籍”的值是一个具体的国家（实例），属性“性别”的值是一个具体的字符串（male / female），而属性“身高”的值则是一个具体的数值

#### 4.关系

**是指概念之间或实体之间或概念与实例之间的联系**，如“运动员”与“足球运动员”两个 概念之间存在的 **父类与子类**（subclassOf）的层次关系；“车轮”和“汽车”两个 **概念之间**存在的 **部分与整体**（partOf）关系；“中国”与“北京”两个 **实体之间**是“首都”关系；“国家”（概念）与“中国”（实体）间是 **实例化**（instanceOf）关系。

<img src="D:\Typora_CACHE\image-20220602202046765.png" alt="image-20220602202046765" style="zoom:67%;" />

### 2.知识图谱的表示

在典型的知识图谱中，每个实体或每个概念用一个全局唯一确定的ID 来标识，称为标识符(identifier)。
**概念**和 **实体**都是通过若干 **属性**来刻画其内在特性。
**概念之间**常见的关系有 **父类与子类**（subclassOf）关系、 **部分与整体**（partOf）关系
实体之间的关系多种多样，不同实体之间存在不同的关系。例如，
“山东省”和“济南市” **两个实体**分别有各自的属性，两者之间存在“provincial_capital”的关系；
“中国”和“北京” **两个实体**之间存在“capital”的关系。所有实体和概念相互关联，形成复杂的“图”。<img src="D:\Typora_CACHE\image-20220602203039075.png" alt="image-20220602203039075" style="zoom:33%;" />

知识图谱的一种通用表示方式是 三元组，与事实性知识的产生式表示方法类
似，也有两种形式：

**属性型联系**：用“属性-值”对(Attribute-Value Pair，AVP)来描述一个
实体具有某种内在属性，形式为 （实体，属性，属性值）
例如，“山东省的面积是15.58平方公里”表示为（山东，面积，15，58平方公里）
**关系型联系**：描述两个实例之间的关系，形式为（实体1，关系，实体2）
例如，“中国的首都是北京”表示为（中国，首都，北京）

### 3.知识图谱的发展历史

<img src="D:\Typora_CACHE\image-20220602203922571.png" alt="image-20220602203922571" style="zoom:67%;" />

#### 1.语义网络表示

**1968**年，认知科学家Allan M. Collins和M. Ross Quillian等人提出了语 语义网络（semantic network， 不是语义网）的心理学模型。

**优点** ：表达形式简单、直观、自然，因此容易理解和展示、相关概念容易聚类。
**缺点**：
（1）没有定义结点与边的值的标准，完全由用户自己定义；
（2）无法区分 **概念结点**和 **实体结点**，如哺乳动物是个 抽象概念，世界上
并没有一种动物名字就叫哺乳动物；；
（3）无法定义节点和边的标签；
（4）难以融合多源数据，不便于知识的共享。
上述缺点导致 **语义网络难以应用于实践**。

#### 2.本体知识表示

**1980** 年，“本体”这一哲学概念被引入人工智能领域中用于刻画知识，便产生了基于本体的知识表示方法，这种知识表示是一种“ **形式化的、对于共享概念体系的明确且详细的说明**”。

本体 显式地定义了领域中的 概念、关系和公理（总是为真的陈述）及其之间的 联系。

#### 3.语义万维网知识表示

语义万维网（Semantic Web）也称为 **语义Web**或语义 **语义网**，与 语义网络（semantic network）的技术理念**完全不同**。

最主要的**区别**在于： 语义网络知识表示与互联网无关，但 语义万维网知识表示却是构建在万维网（world wide web）上的。

**1963**年，泰德·尼尔森（Ted Nelson）创造了“超文本（HyperText）”一词，其含义是用超链接的方法将各种不同空间的文字信息组织在一起的 网状文本。
**1969** 年， 因特网诞生于美国，它的前身“阿帕网”( ARPAnet)是一个军用研究系统，后来才发展成为覆盖五大洲 150 多个国家的开放型全球计算机网络系统，也称为**互联网**。
**1989** 年，英国计算机科学家蒂姆·伯纳斯·李（Lee）创新性地提出了 将**超文本用于因特网**上的构想，并于1990年与同事 Robert Cailliau合作发明了**万维网**（world wide web）技术。
蒂姆·伯纳斯·李又于**1998**年 年提出了“ 语义万维网（语义 Web）”的概念。

**语义web**旨在对互联网内容进行 **语义化表示**，通过对网页进行语义描述，得到网页的语义信息，从而使计算机能够 **理解、推理**互联网信息。
**语义web**是个庞大的构想，仅靠采用可扩展标记语言(extensible markup language，**XML**)标注web页面的数据内容是远远不够的，而是需要新的知识表示手段和方法。
在这样的背景下，科研工作者相继提出了“ **资源描述框架**（ResourceDescription Framework，**RDF**）”和“ **网络本体语言**（Web ontology language，**OWL**）”等面向 Web 的知识表示框架。

**RDF** 包含 主语、谓词和宾语，简称SPO三元组，其中主语和宾语分别表示两个资源，谓词表示两个资源间的关系。
	<Bob> <is a> <person>，
	<Bob> <is a friend of> <Alice>，
	<Bob> <is born on> <the 4th of July 1990>
RDF的 的 局限性： 无法描述类别和属性的 **层级结构、包含关系**。

**OWL** 2001 年，W3C又开发了OWL
OWL 主要在 RDFs 基础上 **扩展了表示类和属性约束的表示能力**，如：复杂类表达（intersection, union 和 complement 等）和属性约束（existential quantification, universal quantification, hasValue 等）， 使得能构建更为复杂且完备的本体。
OWL **复杂度非常高**，在逻辑接近完美，但 工程上实现却**太过复杂**。

**语义网络语语义Web对比**
相较于语义网络，语义Web更加注重于描述万维网中资源、数据之间的语义关系。
W3C针对 **语义Web**制定的标准**解决了语义网络存在的不足**：
	RDF为结点和边的取值提供了 **统一标准**，为多源数据的融合提供了便利；
	RDFs/OWL解决了 **概念和对象的区分问题**，即定义了Class 和 Object(也称作 Instance, Entity)。
**这些标准**从三个方面完善了语义 **完善了语义Web**：
	一是保证了语义Web的内容有准确的含义；
	二是保证了语义Web的内容可以被计算机理解并处理；
	三是计算机可从 Web 上整合各种网页中的内容信息。

此阶段为从“弱语义”到“强语义”的探索

#### 4.链接数据

**2006**年，Lee逐渐意识到 **语义web 的发展遇到了瓶颈**

Lee提出了 **链接数据**（Linked Data）的设想，号召各家单位分享自己的知识库，合并起来形成开放的语义网。
该设想最大的项目是**2007**年5月提出的LOD

自从实践数据链接开始， 在**技术层面**，语义web开始 **弱化“语义推理”**的功能，而更调“Web”的作用，即 **侧重数据的互联互通**，因此linked data可以看作是语义Web的一个简化集合。
在 **实现层面**，linked data提倡使用RDF三元组形式描述知识，很少使用理论更完备的OWL系列方法，降低了实现数据链接的技术难度。
自此，语义Web开始进入 **“弱语义”**的阶段，语义Web的体系结构开始**向知识 图谱过渡**发展。

#### 5.知识图谱的正式提出

 **2012** 年 5 月 17 日，Google 正式提出了知识图谱的概念，发布了称之为“知识图谱”的项目

**谷歌知识图谱进一步弱化了语义，仅保留了 了语义，仅保留了RDF三元组的基本形式**

### 4.典型的知识图谱

“强语义”阶段的典型知识库
是从二十世纪六十年代到2006年，期间，重点研究如何建立语义表示体系，知识库的构建往往依赖于 **专家制定、人工添加、合作编辑**的模式。
此阶段典型知识库应用有：Cyc、WordNet、HowNet和ConceptNet。

“弱语义”阶段的典型知识图谱
自2006年起进入互联网时代后，随着知识库规模的不断增大，搜索引擎成为获取信息的主要手段，人们更多关注的是“是否存在某种知识，且能否找到某种知识”，而不是“是否可以理解、推理某种知识”。显然，这种需求使得知识库越来越 **倾向于“弱语义、大规模 ” ， 不再 强调逻辑复杂的语义及其推理**，而是 **强调**如何利用互联网知识 **自动构建大规模知识图谱**。

### 5.知识图谱的应用

**语义搜索**：

知识图谱引入搜索引擎之后，利用其推理技术，可以发现用户检索词的深层含义，从而以更精确的方式给出搜索结果。

**知识问答**：

问答系统（Question Answering, QA）是指让计算机自动回答用户所提出的问题，是信息服务的一种高级形式。不同于现有的搜索引擎，问答系统返回用户的不再是若干相关文档，而是精准的、单一的语言形式的答案。

# 3.搜索策略

## 1.图搜索策略

图搜索策略就是一种在图中寻找解路径的方法

为了提高搜索效率，图搜索并不是先生成所有状态的连接图、再进行搜索，而是**边搜索边生成图**，直到找到一个符合条件的解，即路径为止。
在搜索的过程中， **生成的无用状态越少**--即非路径上的状态越少，搜索的效率就越高，所对应的 **搜索策略就越好**。

<img src="D:\Typora_CACHE\image-20220602230830545.png" alt="image-20220602230830545" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220602230840534.png" alt="image-20220602230840534" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220602230851672.png" alt="image-20220602230851672" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220602230900364.png" alt="image-20220602230900364" style="zoom:67%;" />

## 2.盲目搜索

盲目搜索也被称为 **无信息搜索 、 通用搜索**。即该搜索策略不使用 **超出问题定义**提供的状态之外的附加信息，只使用问题定义中可用的信息。

完备性：
	当问题有解 时， 保证能找到一个解 。
	当问题 有解，却找不到，就不具有完备性。
最优性 ：
	当问题 有最优解时，保证 能找到最优解（最小损耗路径） 。
	当问题 有最优解，但 找不到， 找到 的 只 是 次优解 ，则不具有最优性。

### 1.深度优先搜索

深度优先搜索的 **基本思想**是**优先扩展深度最深的结点**。
在一个图中，初始 结点 的 深度定义为0，其他结点的深度定义为其父结点的深度加1。

DFS是将OPEN表中的结点按搜索树中结点 **深度** 的 **降序** 排序，深度最大的结点排在最前面，深度相同的结点可以任意排列 。
DFS每次选择一个**深度最深的结点**进行扩展；
如果有相同深度的**多个**结点，则按照事先的约定从中选择一个。
如果该结点 **没有子结点**，即是叶子结点，则选择一个除了该结点以外的深度最深的结点进行扩展。
依次进行下去，直到**找到问题的解**，则结束;
若**再也没有结点可扩展**，则结束，这种情况下表示没有找到问题的解。

**DFS的实现方法**

使用 LIFO (Last-In First-Out)的 **栈**存储OPEN表，把后继结点放在**栈顶**。

<img src="D:\Typora_CACHE\image-20220602232032010.png" alt="image-20220602232032010" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220602232044056.png" alt="image-20220602232044056" style="zoom:67%;" />

**深度优先的性质**

DFS 是**不完备的**、也**不是最优的**。
当深度限制 过深时，会陷入“ 深渊”， **求解效率低**；
若深度限制 过浅，可能找不到解，**即不完备**
最坏情况时，搜索空间等同于穷举

#### 例2.1 八数码问题

<img src="D:\Typora_CACHE\image-20220603152622693.png" alt="image-20220603152622693" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603152636631.png" alt="image-20220603152636631" style="zoom:67%;" />

第一个不算，应为30步

### 2.宽度优先搜索

宽度优先的**搜索策略**：
先扩展根结点，接着扩展根结点的所有后继，然后再扩展它们的后继，依此类推。
BFS每次总是 **优先**扩展 **深度最浅**的结点。
如果有多个结点深度是相同的，则按照事先约定的规则从深度最浅的几个结点中选择一个。
一般地，在下一层的任何结点扩展之前，搜索树上本层深度的所有结点都应该已经扩展过。

<img src="D:\Typora_CACHE\image-20220603153012906.png" alt="image-20220603153012906" style="zoom:67%;" />

**实现方法** 使用**FIFO** (First-In First-Out) **队列**存储OPEN表。

BFS是将OPEN表中的结点按搜索树中结点**深度的增序**排序，**深度最浅**的结点排在最前面（ **队头**），深度相同的结点可以任意排列。
新结点（结点比其父结点深）总是加入到 **队尾**，这意味着浅层的老结点会在深层的新结点之前被扩展。

<img src="D:\Typora_CACHE\image-20220603153120782.png" alt="image-20220603153120782" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603153130942.png" alt="image-20220603153130942" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603153221342.png" alt="image-20220603153221342" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603153456073.png" alt="image-20220603153456073" style="zoom:67%;" />

当问题有解时，一定能找到解. 即BFS 是**完备的**（ （complete） ）。
当问题为单位代价，且问题有解时，一定能找到最优解，即BFS 具有**最优性**。
BFS是一个通用的、与问题无关的方法.
**缺点**：求解问题的**效率较低**。

与BFS相比， **DFS优势**在于：空间复杂度低，因为只存储一条从根到叶子的路径。

在**不要求求解速度**且目标结点的层次 **较深**的情况下, **BFS优于DFS**, 因为BFS一定能够求得问题的解，而DFS在一个扩展得很深但又没有解的分支上进行搜索，是一种无效搜索, 降低了求解的效率,有时甚至不一定能找到问题的解；
在**要求求解速度**且目标结点的层次 **较浅**的情况下, **DFS优于BFS**。因为DFS可快速深入较浅的分支，找到解。

### 3.盲目搜索的特点

盲目搜索策略采用 “**固定**”的搜索模式，不针对具体问题。
**优点**是：适用性强，几乎所有问题都能通过 **深度优先**或者**宽度优先**搜索来求得**全局最优解**。
**缺点**是： 搜索范围比较大，效率比较低

在许多不太复杂的情况下，使用盲目搜索策略也能够取得很好的效果。

## 3.启发式搜索

**启发式搜索策略**采用 **超出问题本身定义**的、问题特有的知识，因此能够找到比无信息搜索更有效的解。

### 评价函数

f(n) = g(n) + h(n). 其中，n为当前结点，即待评价结点。

f(n) 是从初始结点出发、经过结点 n 、到达目标结点的 最佳路径代价值的估计值.
(1) **g(n)** 为从初始结点到结点n 的 最佳路径代价值的 估计值；
(2) **h(n)** 为从结点 n 到目标结点的 最佳路径代价值的估计值，称为**启发式函数**

<img src="D:\Typora_CACHE\image-20220603154424455.png" alt="image-20220603154424455" style="zoom:67%;" />

#### 例 八数码问题

<img src="D:\Typora_CACHE\image-20220603154534482.png" alt="image-20220603154534482" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603154544869.png" alt="image-20220603154544869" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603154553291.png" alt="image-20220603154553291" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603154604035.png" alt="image-20220603154604035" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603154809595.png" alt="image-20220603154809595" style="zoom:67%;" />

### 1.A Search，最佳优先搜索

A 搜索又称为 **最佳优先搜索**（Best-First Search）。
搜索策略：选择数**评价函数 f(n)值最低**的结点作为下一个将要被扩展的结点。
**实现方法**
A 搜索采用 队列存放OPEN表，其中所有结点按照 评价函数值进行 升序排列，最佳结点排在最前面，因此称为“ 最佳优先搜索”。

<img src="D:\Typora_CACHE\image-20220603160308775.png" alt="image-20220603160308775" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603160325353.png" alt="image-20220603160325353" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603160403382.png" alt="image-20220603160403382" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603160412828.png" alt="image-20220603160412828" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603160833463.png" alt="image-20220603160833463" style="zoom:67%;" />

贪婪搜索是最佳优先搜索的特例, 即 f(n) = h(n)，相当于 g(n)=0

贪婪搜索策略不考虑整体最优，仅求取 **局部最优**。
贪婪搜索 不能保证得到最优解，所以，它 **不是最优的**. 但其搜索 **速度非常快**。
贪婪搜索 是**不完备的**。

### 2.A* Search

如果启发函数h(n)满足如下条件：**h(n) ≤ h* (n)**
则可以证明当问题有解时，A算法一定可以找到一个代价值最小的结果，即 **最优解**。满足该条件的A算法称作**A* 算法**。
A*搜索是**最佳优先搜索**的最广为人知的形式，也称为 **最佳图搜索算法**。

A* 算法与A 算法没有 本质区别，只是规定了启发函数的上限，即 h(n) ≤ h* (n)。

**A 搜索既不是完备，也不是最优的 。**
**A* 搜索既是完备的，也是最优的。**

#### 例 八数码问题

<img src="D:\Typora_CACHE\image-20220603165023687.png" alt="image-20220603165023687" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603165640874.png" alt="image-20220603165640874" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603165737077.png" alt="image-20220603165737077" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603165756793.png" alt="image-20220603165756793" style="zoom:67%;" />

#### 例 修道士与野人

<img src="D:\Typora_CACHE\image-20220603170349190.png" alt="image-20220603170349190" style="zoom: 67%;" />

<img src="D:\Typora_CACHE\image-20220603170401131.png" alt="image-20220603170401131" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603170412481.png" alt="image-20220603170412481" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603170543757.png" alt="image-20220603170543757" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603173353248.png" alt="image-20220603173353248" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603173509639.png" alt="image-20220603173509639" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603173718714.png" alt="image-20220603173718714" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603173739019.png" alt="image-20220603173739019" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603173945814.png" alt="image-20220603173945814" style="zoom:67%;" />

## 4.超越经典搜索

### 1.爬山搜索

#### 1.爬山法

爬山法是最基本的局部搜索技术。爬山法(最陡上升版本)搜索，是简单的循环过程，不断向值增加的方向持续移动—— 即，登高

这里，最佳邻接结点就是 启发式 代价评估 函数h值 值最低的邻接结点。

<img src="D:\Typora_CACHE\image-20220603181907242.png" alt="image-20220603181907242" style="zoom:67%;" />

爬山法是一种 **迭代算法**：开始时选择问题的一个任意解，然后递增地修改该解的一个元素，若得到一个更好的解，则将该修改作为新的解；重复上述步骤直到无法找到进一步的改善。

爬山法有时被称为 **贪婪局部搜索**

#### 2.爬山法的弱点

1.局部最大值 爬山法到达局部极大值附近，就会被拉向峰顶，然后就卡在局部极大值处无处可走。

2.高原 是一块平原区域，是平的局部极大值，不存在上山的出口。

3.山脊 结果是一系列局部最大值，非常难爬行

#### 例 解决n皇后问题

<img src="D:\Typora_CACHE\image-20220603182148373.png" alt="image-20220603182148373" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603182246285.png" alt="image-20220603182246285" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603183800079.png" alt="image-20220603183800079" style="zoom:67%;" />

贪婪算法 **很难处理陷入局部极大值**的情况。
在这种情况下，爬山法均无法再取得进展。
从随机生成的八皇后问题开始，采用最陡上升的爬山法，其中**86% 的情况下会被卡住**， **只有14% 的问题实例能求得解**。
到现在为止，我们描述的爬山法是**不完备的**—— 它们经常会在存在目标的情况下，因为被局部极大值卡住而**找不到目标**。

#### 3.爬山法变型

Stochastic hill-climbing **随机爬山法**
在向上移动的过程中， **随机地选择下一步，即不一定选择最陡的路径走**, 被选中的概率可能随向上移动的陡峭程度的不同而变化。
与最陡上升算法相比， 收敛速度通常较慢。
**随机爬山法仍然不完备**，还会被局部极大值卡住。

Random-restart hill-climbing **随机重启爬山法**
**随机生成一个初始状态**，开始搜索，执行一系列这样的爬山搜索，直到找到目标为止。
随机重启 爬山法**依然不完备**，**但以逼近1 的概率接近完备**，因为最终它将生成一个目标状态作为初始状态。
如果每次爬山搜索成功的概率为p，则重启需要的期望值是1/p。
对于八皇后问题，随机重启爬山法实际上是有效的。即使**有300 万个皇后，这个方法找到解的时间不超过1分钟**。
爬山法成功与否**严重依赖于状态空间地形图的形状**：如果在图中几乎没有局部极大值和高原， 随机重启爬山法会很快找到一个好的解。

### 2.模拟退火搜索

将 爬山法 和随机行走以某种方式 结合，同时得到 效率 和 完备性的想法是合理的。模拟退火就是这样的算法。

模拟退火算法的内层循环与爬山法类似，只是它 没有选择最佳移动，选择的是 随机移动。
如果该移动能改善情况，该移动则被接受；否则，算法以某个小于1 的概率接受该（变坏的）移动。
随着移动导致状态“变坏”， **接受概率会呈指数级下降**——根据**能量差值**ΔE 判断。
这个**概率也随“温度”T的降低而下降**：开始T高的时候，可能允许“坏的”移动；当T降低时，则不可能允许“坏的”移动。
如果调度让温度T下降得足够慢，算法找到全局最优解的概率接近于1。
模拟退火在20 世纪80 年代早期，被广泛用于求解VLSI (大规模集成电路)布局问题。现在它已经广泛地应用于工厂调度和其他大型最优化任务。

<img src="D:\Typora_CACHE\image-20220603184905286.png" alt="image-20220603184905286" style="zoom:67%;" />

### 3.遗传算法

遗传算法是一种模仿自然选择过程的**启发式搜索**算法。

遗传算法属于**进化算法**这个大分类。

**种群**（Population）：是初始时给定的**多个解的集合**，其中有一组k个随机生成的状态，称其为 **种群**。
**个体**（Individual）：指种群中的单个状态，用于描述其基本遗传结构的**数据结构**，表示为有限字母表上的一个字符串，通常是0和1的字符串。
**染色体**（Chromosome）：指对个体进行编码后所得到的**编码串**。染色体中的每一位称为基因，染色体上由若干个基因构成的一个有效信息段称为**基因组**。例如：11011为一个染色体，每一位上的0或1表示基因。

**适应度**（Fitness） **函数**：一种用来对种群中各个个体的**环境适应性**进行度量的**函数**。其函数值是遗传算法实现 **优胜劣汰**的主要依据。
对于好的状态，适应度函数应返回较高的值，即： **适应度越高，越好**。
**遗传操作**（Genetic Operator）：指作用于种群而产生新的种群的操作。
标准的遗传操作包括以下三种基本形式：
	选择（Selection）
	交叉（Crossover）
	变异（Mutation）

#### 例8皇后

<img src="D:\Typora_CACHE\image-20220603191351730.png" alt="image-20220603191351730" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603191430356.png" alt="image-20220603191430356" style="zoom:67%;" />

<img src="D:\Typora_CACHE\image-20220603191506645.png" alt="image-20220603191506645" style="zoom:67%;" />

# 4.机器学习 

## 1.机器学习的三个视角

### 1.机器学习的概念

**机器学习**是**人工智能**的一个分支，是实现智能的关键。其目标是要构建可以从数据中**学习**、并对数据进行**预测**的系统。

### 2.机器学习的发展历史

### 3.机器学习的三个不同视角

### 4.机器学习的应用于术语

## 2.机器学习的人物

## 3.机器学习的范式（类型）

## 4.机器学习模型

# 5.神经网络

## 1.人工神经网络的发展历史

## 2.人工神经网络

## 3.卷积神经网络

## 4.深度神经网络

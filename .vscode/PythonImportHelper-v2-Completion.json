[
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "hmac",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hmac",
        "description": "hmac",
        "detail": "hmac",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "brainpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "brainpy",
        "description": "brainpy",
        "detail": "brainpy",
        "documentation": {}
    },
    {
        "label": "brainpy.math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "brainpy.math",
        "description": "brainpy.math",
        "detail": "brainpy.math",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "empty",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "empty",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "zeros",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "ones",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "empty",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "empty",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "arange",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "empty",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "zeros",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "zeros",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "jax.numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jax.numpy",
        "description": "jax.numpy",
        "detail": "jax.numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "timeit",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "timeit",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "repeat",
        "importPath": "timeit",
        "description": "timeit",
        "isExtraImport": true,
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "perf_counter",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "stdout",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "MPI",
        "importPath": "mpi4py",
        "description": "mpi4py",
        "isExtraImport": true,
        "detail": "mpi4py",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "Cartcomm",
        "importPath": "mpi4py.MPI",
        "description": "mpi4py.MPI",
        "isExtraImport": true,
        "detail": "mpi4py.MPI",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "importPath": "fib",
        "description": "fib",
        "isExtraImport": true,
        "detail": "fib",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "importPath": "fib_py",
        "description": "fib_py",
        "isExtraImport": true,
        "detail": "fib_py",
        "documentation": {}
    },
    {
        "label": "fibonacci_cached",
        "importPath": "fib_py",
        "description": "fib_py",
        "isExtraImport": true,
        "detail": "fib_py",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat",
        "description": "heat",
        "isExtraImport": true,
        "detail": "heat",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "compute_mandel",
        "importPath": "mandel",
        "description": "mandel",
        "isExtraImport": true,
        "detail": "mandel",
        "documentation": {}
    },
    {
        "label": "compute_mandel",
        "importPath": "mandel",
        "description": "mandel",
        "isExtraImport": true,
        "detail": "mandel",
        "documentation": {}
    },
    {
        "label": "FFI",
        "importPath": "cffi",
        "description": "cffi",
        "isExtraImport": true,
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "FFI",
        "importPath": "cffi",
        "description": "cffi",
        "isExtraImport": true,
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "add",
        "description": "add",
        "detail": "add",
        "documentation": {}
    },
    {
        "label": "molecule",
        "importPath": "ase.build",
        "description": "ase.build",
        "isExtraImport": true,
        "detail": "ase.build",
        "documentation": {}
    },
    {
        "label": "GPAW",
        "importPath": "gpaw",
        "description": "gpaw",
        "isExtraImport": true,
        "detail": "gpaw",
        "documentation": {}
    },
    {
        "label": "cProfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cProfile",
        "description": "cProfile",
        "detail": "cProfile",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "multiply",
        "importPath": "matmul",
        "description": "matmul",
        "isExtraImport": true,
        "detail": "matmul",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Lock",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Manager",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Array",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Manager",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Array",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pipe",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pool",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "ffi",
        "importPath": "_evolve",
        "description": "_evolve",
        "isExtraImport": true,
        "detail": "_evolve",
        "documentation": {}
    },
    {
        "label": "lib",
        "importPath": "_evolve",
        "description": "_evolve",
        "isExtraImport": true,
        "detail": "_evolve",
        "documentation": {}
    },
    {
        "label": "evolve_py",
        "importPath": "evolve_cyt",
        "description": "evolve_cyt",
        "isExtraImport": true,
        "detail": "evolve_cyt",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "importPath": "heat_cffi",
        "description": "heat_cffi",
        "isExtraImport": true,
        "detail": "heat_cffi",
        "documentation": {}
    },
    {
        "label": "write_field",
        "importPath": "heat_cffi",
        "description": "heat_cffi",
        "isExtraImport": true,
        "detail": "heat_cffi",
        "documentation": {}
    },
    {
        "label": "iterate",
        "importPath": "heat_cffi",
        "description": "heat_cffi",
        "isExtraImport": true,
        "detail": "heat_cffi",
        "documentation": {}
    },
    {
        "label": "evolve",
        "importPath": "evolve_mod",
        "description": "evolve_mod",
        "isExtraImport": true,
        "detail": "evolve_mod",
        "documentation": {}
    },
    {
        "label": "evolve",
        "importPath": "evolve",
        "description": "evolve",
        "isExtraImport": true,
        "detail": "evolve",
        "documentation": {}
    },
    {
        "label": "Fasta",
        "importPath": "fasta",
        "description": "fasta",
        "isExtraImport": true,
        "detail": "fasta",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "PDB",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "PDB",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "PDB",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "numpy.ma",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.ma",
        "description": "numpy.ma",
        "detail": "numpy.ma",
        "documentation": {}
    },
    {
        "label": "OptionParser",
        "importPath": "optparse",
        "description": "optparse",
        "isExtraImport": true,
        "detail": "optparse",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "calculate_jws_token",
        "kind": 2,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "def calculate_jws_token(sub, name, school, course, iat, key):\n    header = {\n        \"alg\": \"HS256\",\n        \"typ\": \"JWT\"\n    }\n    payload = {\n        \"sub\": sub,\n        \"name\": name,\n        \"school\": school,\n        \"course\": course,",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "sub",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "sub = \"20301037\"\nname = \"贺思超\"\nschool = \"软件学院\"\ncourse = \"API设计与实现\"\niat = 1516239022\nkey = hashlib.md5(sub.encode('utf-8')).hexdigest()\n# 计算 JWS Token\njws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "name = \"贺思超\"\nschool = \"软件学院\"\ncourse = \"API设计与实现\"\niat = 1516239022\nkey = hashlib.md5(sub.encode('utf-8')).hexdigest()\n# 计算 JWS Token\njws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "school",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "school = \"软件学院\"\ncourse = \"API设计与实现\"\niat = 1516239022\nkey = hashlib.md5(sub.encode('utf-8')).hexdigest()\n# 计算 JWS Token\njws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "course",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "course = \"API设计与实现\"\niat = 1516239022\nkey = hashlib.md5(sub.encode('utf-8')).hexdigest()\n# 计算 JWS Token\njws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "iat",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "iat = 1516239022\nkey = hashlib.md5(sub.encode('utf-8')).hexdigest()\n# 计算 JWS Token\njws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "key",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "key = hashlib.md5(sub.encode('utf-8')).hexdigest()\n# 计算 JWS Token\njws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "jws_token",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_jws",
        "description": "API设计与实现(updating).hw.hw2.test_jws",
        "peekOfCode": "jws_token = calculate_jws_token(sub, name, school, course, iat, key)\n# 打印结果\nprint(\"JWS Token:\", jws_token)",
        "detail": "API设计与实现(updating).hw.hw2.test_jws",
        "documentation": {}
    },
    {
        "label": "calculate_sign1",
        "kind": 2,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "def calculate_sign1(app_id, req_id, req_time, app_secret):\n    sign_str = f\"appId={app_id}&reqId={req_id}&reqTime={req_time}&appSecret={app_secret}\"\n    return hashlib.md5(sign_str.encode('utf-8')).hexdigest()\ndef calculate_sign2(app_id, req_id, req_time, app_secret, data):\n    hash1 = hashlib.md5(data.encode('utf-8')).hexdigest()\n    sign_str = f\"appId={app_id}&data={hash1}&reqId={req_id}&reqTime={req_time}&appSecret={app_secret}\"\n    return hashlib.md5(sign_str.encode('utf-8')).hexdigest()\n# data\napp_id = \"20301037\"\nreq_id = f\"API02_{str(uuid.uuid4())[:8]}\"  # 使用UUID4生成req_id",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "calculate_sign2",
        "kind": 2,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "def calculate_sign2(app_id, req_id, req_time, app_secret, data):\n    hash1 = hashlib.md5(data.encode('utf-8')).hexdigest()\n    sign_str = f\"appId={app_id}&data={hash1}&reqId={req_id}&reqTime={req_time}&appSecret={app_secret}\"\n    return hashlib.md5(sign_str.encode('utf-8')).hexdigest()\n# data\napp_id = \"20301037\"\nreq_id = f\"API02_{str(uuid.uuid4())[:8]}\"  # 使用UUID4生成req_id\nreq_time = \"1682915696123\"\napp_secret = hashlib.md5(app_id.encode('utf-8')).hexdigest()\ndata = '{\"name\": \"贺思超\", \"school\": \"软件学院\", \"course\": \"API设计与实现\"}'",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "app_id",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "app_id = \"20301037\"\nreq_id = f\"API02_{str(uuid.uuid4())[:8]}\"  # 使用UUID4生成req_id\nreq_time = \"1682915696123\"\napp_secret = hashlib.md5(app_id.encode('utf-8')).hexdigest()\ndata = '{\"name\": \"贺思超\", \"school\": \"软件学院\", \"course\": \"API设计与实现\"}'\n# 计算签名值\nsign1 = calculate_sign1(app_id, req_id, req_time, app_secret)\nsign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "req_id",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "req_id = f\"API02_{str(uuid.uuid4())[:8]}\"  # 使用UUID4生成req_id\nreq_time = \"1682915696123\"\napp_secret = hashlib.md5(app_id.encode('utf-8')).hexdigest()\ndata = '{\"name\": \"贺思超\", \"school\": \"软件学院\", \"course\": \"API设计与实现\"}'\n# 计算签名值\nsign1 = calculate_sign1(app_id, req_id, req_time, app_secret)\nsign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")\nprint(\"1) 签名逻辑 1:\", sign1)",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "req_time",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "req_time = \"1682915696123\"\napp_secret = hashlib.md5(app_id.encode('utf-8')).hexdigest()\ndata = '{\"name\": \"贺思超\", \"school\": \"软件学院\", \"course\": \"API设计与实现\"}'\n# 计算签名值\nsign1 = calculate_sign1(app_id, req_id, req_time, app_secret)\nsign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")\nprint(\"1) 签名逻辑 1:\", sign1)\nprint(\"2) 签名逻辑 2:\", sign2)",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "app_secret",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "app_secret = hashlib.md5(app_id.encode('utf-8')).hexdigest()\ndata = '{\"name\": \"贺思超\", \"school\": \"软件学院\", \"course\": \"API设计与实现\"}'\n# 计算签名值\nsign1 = calculate_sign1(app_id, req_id, req_time, app_secret)\nsign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")\nprint(\"1) 签名逻辑 1:\", sign1)\nprint(\"2) 签名逻辑 2:\", sign2)",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "data = '{\"name\": \"贺思超\", \"school\": \"软件学院\", \"course\": \"API设计与实现\"}'\n# 计算签名值\nsign1 = calculate_sign1(app_id, req_id, req_time, app_secret)\nsign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")\nprint(\"1) 签名逻辑 1:\", sign1)\nprint(\"2) 签名逻辑 2:\", sign2)",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "sign1",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "sign1 = calculate_sign1(app_id, req_id, req_time, app_secret)\nsign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")\nprint(\"1) 签名逻辑 1:\", sign1)\nprint(\"2) 签名逻辑 2:\", sign2)",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "sign2",
        "kind": 5,
        "importPath": "API设计与实现(updating).hw.hw2.test_sign",
        "description": "API设计与实现(updating).hw.hw2.test_sign",
        "peekOfCode": "sign2 = calculate_sign2(app_id, req_id, req_time, app_secret, data)\n# 打印结果\nprint(f\"appId: {app_id}, \\nreqId: {req_id}, \\nreqTime: {req_time}, \\nappSecret: {app_secret}, \\ndata: {data}\")\nprint(\"1) 签名逻辑 1:\", sign1)\nprint(\"2) 签名逻辑 2:\", sign2)",
        "detail": "API设计与实现(updating).hw.hw2.test_sign",
        "documentation": {}
    },
    {
        "label": "bm_array",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.array",
        "description": "BrainPy.code.basic_knowledge.array",
        "peekOfCode": "bm_array = bm.array([0, 1, 2, 3, 4, 5])\nnp_array = np.array([0, 1, 2, 3, 4, 5])\nprint('bm: ', bm_array)\nprint('np: ', np_array)\nt2 = bm.array([[[0, 1, 2, 3], [1, 2, 3, 4], [4, 5, 6, 7]],\n                [[0, 0, 0, 0], [-1, 1, -1, 1], [2, -2, 2, -2]]])\nprint('t2: ', t2)\nprint('t2.ndim: {}'.format(t2.ndim))\nprint('t2.shape: {}'.format(t2.shape))\nprint('t2.size: {}'.format(t2.size))",
        "detail": "BrainPy.code.basic_knowledge.array",
        "documentation": {}
    },
    {
        "label": "np_array",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.array",
        "description": "BrainPy.code.basic_knowledge.array",
        "peekOfCode": "np_array = np.array([0, 1, 2, 3, 4, 5])\nprint('bm: ', bm_array)\nprint('np: ', np_array)\nt2 = bm.array([[[0, 1, 2, 3], [1, 2, 3, 4], [4, 5, 6, 7]],\n                [[0, 0, 0, 0], [-1, 1, -1, 1], [2, -2, 2, -2]]])\nprint('t2: ', t2)\nprint('t2.ndim: {}'.format(t2.ndim))\nprint('t2.shape: {}'.format(t2.shape))\nprint('t2.size: {}'.format(t2.size))\nprint('t2.dtype: {}'.format(t2.dtype))",
        "detail": "BrainPy.code.basic_knowledge.array",
        "documentation": {}
    },
    {
        "label": "t2",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.array",
        "description": "BrainPy.code.basic_knowledge.array",
        "peekOfCode": "t2 = bm.array([[[0, 1, 2, 3], [1, 2, 3, 4], [4, 5, 6, 7]],\n                [[0, 0, 0, 0], [-1, 1, -1, 1], [2, -2, 2, -2]]])\nprint('t2: ', t2)\nprint('t2.ndim: {}'.format(t2.ndim))\nprint('t2.shape: {}'.format(t2.shape))\nprint('t2.size: {}'.format(t2.size))\nprint('t2.dtype: {}'.format(t2.dtype))",
        "detail": "BrainPy.code.basic_knowledge.array",
        "documentation": {}
    },
    {
        "label": "integral",
        "kind": 2,
        "importPath": "BrainPy.code.basic_knowledge.diff",
        "description": "BrainPy.code.basic_knowledge.diff",
        "peekOfCode": "def integral(V, w, t, Iext, a, b, tau):\n    dw = (V + a - b * w) / tau\n    dV = V - V * V * V / 3 - w + Iext\n    return dV, dw\na_param = 0.7\nb_param = 0.8\ntau_param = 12.5\nIext_param = 1\nrunner = bp.integrators.IntegratorRunner(\n    integral,",
        "detail": "BrainPy.code.basic_knowledge.diff",
        "documentation": {}
    },
    {
        "label": "a_param",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.diff",
        "description": "BrainPy.code.basic_knowledge.diff",
        "peekOfCode": "a_param = 0.7\nb_param = 0.8\ntau_param = 12.5\nIext_param = 1\nrunner = bp.integrators.IntegratorRunner(\n    integral,\n    monitors=['V'],\n    inits=dict(V=0., w=0.),\n    args=dict(a=a_param, b=b_param, tau=tau_param, Iext=Iext_param),\n    dt=0.01,",
        "detail": "BrainPy.code.basic_knowledge.diff",
        "documentation": {}
    },
    {
        "label": "b_param",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.diff",
        "description": "BrainPy.code.basic_knowledge.diff",
        "peekOfCode": "b_param = 0.8\ntau_param = 12.5\nIext_param = 1\nrunner = bp.integrators.IntegratorRunner(\n    integral,\n    monitors=['V'],\n    inits=dict(V=0., w=0.),\n    args=dict(a=a_param, b=b_param, tau=tau_param, Iext=Iext_param),\n    dt=0.01,\n)",
        "detail": "BrainPy.code.basic_knowledge.diff",
        "documentation": {}
    },
    {
        "label": "tau_param",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.diff",
        "description": "BrainPy.code.basic_knowledge.diff",
        "peekOfCode": "tau_param = 12.5\nIext_param = 1\nrunner = bp.integrators.IntegratorRunner(\n    integral,\n    monitors=['V'],\n    inits=dict(V=0., w=0.),\n    args=dict(a=a_param, b=b_param, tau=tau_param, Iext=Iext_param),\n    dt=0.01,\n)\nrunner.run(100.)",
        "detail": "BrainPy.code.basic_knowledge.diff",
        "documentation": {}
    },
    {
        "label": "Iext_param",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.diff",
        "description": "BrainPy.code.basic_knowledge.diff",
        "peekOfCode": "Iext_param = 1\nrunner = bp.integrators.IntegratorRunner(\n    integral,\n    monitors=['V'],\n    inits=dict(V=0., w=0.),\n    args=dict(a=a_param, b=b_param, tau=tau_param, Iext=Iext_param),\n    dt=0.01,\n)\nrunner.run(100.)\nplt.plot(runner.mon.ts, runner.mon.V)",
        "detail": "BrainPy.code.basic_knowledge.diff",
        "documentation": {}
    },
    {
        "label": "runner",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.diff",
        "description": "BrainPy.code.basic_knowledge.diff",
        "peekOfCode": "runner = bp.integrators.IntegratorRunner(\n    integral,\n    monitors=['V'],\n    inits=dict(V=0., w=0.),\n    args=dict(a=a_param, b=b_param, tau=tau_param, Iext=Iext_param),\n    dt=0.01,\n)\nrunner.run(100.)\nplt.plot(runner.mon.ts, runner.mon.V)\nplt.show()",
        "detail": "BrainPy.code.basic_knowledge.diff",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "kind": 6,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "class LogisticRegression(bp.Base):\n    def __init__(self, dimension):\n        super(LogisticRegression, self).__init__()\n        # 参数定义\n        self.dimension = dimension\n        # 动态变量定义\n        self.w = bm.Variable(2.0 * bm.ones(dimension) - 1.3)\n    def __call__(self, X, Y):\n        u = bm.dot(((1.0 / (1.0 + bm.exp(-Y * bm.dot(X, self.w))) - 1.0) * Y), X)\n        self.w.value = self.w - u # 就地更新动态变量",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "benchmark",
        "kind": 2,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "def benchmark(model, points, labels, num_iter=30, name=''):\n    t0 = time.time()\n    for i in range(num_iter):\n        model(points, labels)\n    print(f'{name} time: {time.time() - t0} s')\nnum_dim, num_points = 10, 20000000\npoints = bm.random.random((num_points, num_dim))\nlabels = bm.random.random(num_points)\nlr1 = LogisticRegression(num_dim)\nbenchmark(lr1, points, labels, name='Logistic Regression (without jit)')",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "points = bm.random.random((num_points, num_dim))\nlabels = bm.random.random(num_points)\nlr1 = LogisticRegression(num_dim)\nbenchmark(lr1, points, labels, name='Logistic Regression (without jit)')\nlr2 = LogisticRegression(num_dim)\nlr2 = bm.jit(lr2)\nbenchmark(lr2, points, labels, name='Logistic Regression (with jit)')",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "labels = bm.random.random(num_points)\nlr1 = LogisticRegression(num_dim)\nbenchmark(lr1, points, labels, name='Logistic Regression (without jit)')\nlr2 = LogisticRegression(num_dim)\nlr2 = bm.jit(lr2)\nbenchmark(lr2, points, labels, name='Logistic Regression (with jit)')",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "lr1",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "lr1 = LogisticRegression(num_dim)\nbenchmark(lr1, points, labels, name='Logistic Regression (without jit)')\nlr2 = LogisticRegression(num_dim)\nlr2 = bm.jit(lr2)\nbenchmark(lr2, points, labels, name='Logistic Regression (with jit)')",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "lr2",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "lr2 = LogisticRegression(num_dim)\nlr2 = bm.jit(lr2)\nbenchmark(lr2, points, labels, name='Logistic Regression (with jit)')",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "lr2",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_class",
        "description": "BrainPy.code.basic_knowledge.jit_class",
        "peekOfCode": "lr2 = bm.jit(lr2)\nbenchmark(lr2, points, labels, name='Logistic Regression (with jit)')",
        "detail": "BrainPy.code.basic_knowledge.jit_class",
        "documentation": {}
    },
    {
        "label": "gelu",
        "kind": 2,
        "importPath": "BrainPy.code.basic_knowledge.jit_function",
        "description": "BrainPy.code.basic_knowledge.jit_function",
        "peekOfCode": "def gelu(x):\n    sqrt = bm.sqrt(2 / bm.pi)\n    cdf = 0.5 * (1.0 + bm.tanh(sqrt * (x + 0.044715 * (x ** 3))))\n    y = x * cdf\n    return y\nx = bm.random.random(100000)\nprint('python: ', timeit(lambda: gelu(x), number=100))\n# jit\ngelu_jit = bm.jit(gelu)\nprint('jit: ', timeit(lambda: gelu_jit(x), number=100))",
        "detail": "BrainPy.code.basic_knowledge.jit_function",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_function",
        "description": "BrainPy.code.basic_knowledge.jit_function",
        "peekOfCode": "x = bm.random.random(100000)\nprint('python: ', timeit(lambda: gelu(x), number=100))\n# jit\ngelu_jit = bm.jit(gelu)\nprint('jit: ', timeit(lambda: gelu_jit(x), number=100))",
        "detail": "BrainPy.code.basic_knowledge.jit_function",
        "documentation": {}
    },
    {
        "label": "gelu_jit",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.jit_function",
        "description": "BrainPy.code.basic_knowledge.jit_function",
        "peekOfCode": "gelu_jit = bm.jit(gelu)\nprint('jit: ', timeit(lambda: gelu_jit(x), number=100))",
        "detail": "BrainPy.code.basic_knowledge.jit_function",
        "documentation": {}
    },
    {
        "label": "EINet",
        "kind": 6,
        "importPath": "BrainPy.code.basic_knowledge.runner",
        "description": "BrainPy.code.basic_knowledge.runner",
        "peekOfCode": "class EINet(bp.Network):\n    def __init__(self, scale:1.0, method='exp_auto'):\n        super(EINet, self).__init__()\n        num_exc = int(3200 * scale)\n        num_inh = int(800 * scale)\n        pars = dict(V_rest=-60., V_th=-50., V_reset=-60., tau=20., tau_ref=5.)\n        self.E = bp.neurons.LIF(num_exc, **pars, method=method)\n        self.I = bp.neurons.LIF(num_inh, **pars, method=method)\n        self.E.V[:] = bm.random.random(num_exc) * 2 - 55.\n        self.I.V[:] = bm.random.random(num_inh) * 2 - 55.",
        "detail": "BrainPy.code.basic_knowledge.runner",
        "documentation": {}
    },
    {
        "label": "net",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.runner",
        "description": "BrainPy.code.basic_knowledge.runner",
        "peekOfCode": "net = EINet(scale=1., method='exp_auto')\nrunner = bp.DSRunner(\n    net,\n    monitors={'E.spike': net.E.spike},\n    inputs=[(net.E.input, 20.), (net.I.input, 20.)]\n)\nrunner.run(1000.)\nbp.visualize.raster_plot(runner.mon.ts, runner.mon['E.spike'], show=True)",
        "detail": "BrainPy.code.basic_knowledge.runner",
        "documentation": {}
    },
    {
        "label": "runner",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.runner",
        "description": "BrainPy.code.basic_knowledge.runner",
        "peekOfCode": "runner = bp.DSRunner(\n    net,\n    monitors={'E.spike': net.E.spike},\n    inputs=[(net.E.input, 20.), (net.I.input, 20.)]\n)\nrunner.run(1000.)\nbp.visualize.raster_plot(runner.mon.ts, runner.mon['E.spike'], show=True)",
        "detail": "BrainPy.code.basic_knowledge.runner",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.synapse",
        "description": "BrainPy.code.basic_knowledge.synapse",
        "peekOfCode": "conn = bp.connect.FixedProb(prob=0.2, include_self=False)\nprint(conn)\nconn = conn(pre_size=4, post_size=4)\nres = conn.require('conn_mat', 'pre_ids', 'post_ids', 'pre2post', 'pre2syn')\nprint(res[0])\n# pre post: 对应连接的前后神经元\nprint('pre ids: {}'.format(res[1]))\nprint('post ids: {}'.format(res[2]))\n# pre2post: 两个数组, 第一个为post的序号,\n# 第二个为与第i号pre神经元相连的post神经元在第一个数组中的开始和节数位置",
        "detail": "BrainPy.code.basic_knowledge.synapse",
        "documentation": {}
    },
    {
        "label": "conn",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.synapse",
        "description": "BrainPy.code.basic_knowledge.synapse",
        "peekOfCode": "conn = conn(pre_size=4, post_size=4)\nres = conn.require('conn_mat', 'pre_ids', 'post_ids', 'pre2post', 'pre2syn')\nprint(res[0])\n# pre post: 对应连接的前后神经元\nprint('pre ids: {}'.format(res[1]))\nprint('post ids: {}'.format(res[2]))\n# pre2post: 两个数组, 第一个为post的序号,\n# 第二个为与第i号pre神经元相连的post神经元在第一个数组中的开始和节数位置\nprint('post ids: {}'.format(res[3][0]))\nprint('pre ptr: {}'.format(res[3][1]))",
        "detail": "BrainPy.code.basic_knowledge.synapse",
        "documentation": {}
    },
    {
        "label": "res",
        "kind": 5,
        "importPath": "BrainPy.code.basic_knowledge.synapse",
        "description": "BrainPy.code.basic_knowledge.synapse",
        "peekOfCode": "res = conn.require('conn_mat', 'pre_ids', 'post_ids', 'pre2post', 'pre2syn')\nprint(res[0])\n# pre post: 对应连接的前后神经元\nprint('pre ids: {}'.format(res[1]))\nprint('post ids: {}'.format(res[2]))\n# pre2post: 两个数组, 第一个为post的序号,\n# 第二个为与第i号pre神经元相连的post神经元在第一个数组中的开始和节数位置\nprint('post ids: {}'.format(res[3][0]))\nprint('pre ptr: {}'.format(res[3][1]))\n# pre2syn: 与pre2post类似, 将post换成syn",
        "detail": "BrainPy.code.basic_knowledge.synapse",
        "documentation": {}
    },
    {
        "label": "FitzHughNagumo",
        "kind": 6,
        "importPath": "BrainPy.code.basic_knowledge.update",
        "description": "BrainPy.code.basic_knowledge.update",
        "peekOfCode": "class FitzHughNagumo(bp.DynamicalSystem):\n    def __init__(self, size, a=0.7, b=0.8, tau=12.5):\n        super(FitzHughNagumo, self).__init__()\n        # 参数\n        self.a = a\n        self.b = b\n        self.tau = tau\n        # 变量\n        self.V = bm.Variable(bm.ones(size))\n        self.w = bm.Variable(bm.zeros(size))",
        "detail": "BrainPy.code.basic_knowledge.update",
        "documentation": {}
    },
    {
        "label": "Asset",
        "kind": 6,
        "importPath": "scripts.report_large_assets",
        "description": "scripts.report_large_assets",
        "peekOfCode": "class Asset:\n    path: Path\n    size_bytes: int\n    @property\n    def size_mb(self) -> float:\n        return self.size_bytes / (1024 * 1024)\ndef iter_assets(root: Path, min_bytes: int) -> Iterable[Asset]:\n    for path in root.rglob(\"*\"):\n        if not path.is_file():\n            continue",
        "detail": "scripts.report_large_assets",
        "documentation": {}
    },
    {
        "label": "iter_assets",
        "kind": 2,
        "importPath": "scripts.report_large_assets",
        "description": "scripts.report_large_assets",
        "peekOfCode": "def iter_assets(root: Path, min_bytes: int) -> Iterable[Asset]:\n    for path in root.rglob(\"*\"):\n        if not path.is_file():\n            continue\n        if any(part in EXCLUDE_DIRS for part in path.parts):\n            continue\n        size = path.stat().st_size\n        if size >= min_bytes:\n            yield Asset(path=path.relative_to(root), size_bytes=size)\ndef format_table(rows: List[Asset]) -> str:",
        "detail": "scripts.report_large_assets",
        "documentation": {}
    },
    {
        "label": "format_table",
        "kind": 2,
        "importPath": "scripts.report_large_assets",
        "description": "scripts.report_large_assets",
        "peekOfCode": "def format_table(rows: List[Asset]) -> str:\n    lines = [f\"Found {len(rows)} files ≥ threshold:\\n\"]\n    width = max((len(str(asset.path)) for asset in rows), default=0)\n    for asset in rows:\n        lines.append(f\"{str(asset.path):<{width}}  {asset.size_mb:6.1f} MB\")\n    return \"\\n\".join(lines)\ndef main() -> int:\n    parser = argparse.ArgumentParser(description=\"Report large files inside the repository\")\n    parser.add_argument(\"--root\", type=Path, default=Path.cwd(), help=\"Repository root (default: cwd)\")\n    parser.add_argument(\"--min-mb\", type=float, default=DEFAULT_MIN_MB, help=\"Minimum file size in MB\")",
        "detail": "scripts.report_large_assets",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.report_large_assets",
        "description": "scripts.report_large_assets",
        "peekOfCode": "def main() -> int:\n    parser = argparse.ArgumentParser(description=\"Report large files inside the repository\")\n    parser.add_argument(\"--root\", type=Path, default=Path.cwd(), help=\"Repository root (default: cwd)\")\n    parser.add_argument(\"--min-mb\", type=float, default=DEFAULT_MIN_MB, help=\"Minimum file size in MB\")\n    parser.add_argument(\"--json\", type=Path, help=\"Optional path to write machine-readable JSON report\")\n    args = parser.parse_args()\n    min_bytes = int(args.min_mb * 1024 * 1024)\n    assets = sorted(iter_assets(args.root, min_bytes), key=lambda item: item.size_bytes, reverse=True)\n    if assets:\n        print(format_table(assets))",
        "detail": "scripts.report_large_assets",
        "documentation": {}
    },
    {
        "label": "EXCLUDE_DIRS",
        "kind": 5,
        "importPath": "scripts.report_large_assets",
        "description": "scripts.report_large_assets",
        "peekOfCode": "EXCLUDE_DIRS = {\".git\", \".venv\", \"venv\", \"node_modules\", \"__pycache__\", \"docs/data\"}\nDEFAULT_MIN_MB = 20\n@dataclass\nclass Asset:\n    path: Path\n    size_bytes: int\n    @property\n    def size_mb(self) -> float:\n        return self.size_bytes / (1024 * 1024)\ndef iter_assets(root: Path, min_bytes: int) -> Iterable[Asset]:",
        "detail": "scripts.report_large_assets",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MIN_MB",
        "kind": 5,
        "importPath": "scripts.report_large_assets",
        "description": "scripts.report_large_assets",
        "peekOfCode": "DEFAULT_MIN_MB = 20\n@dataclass\nclass Asset:\n    path: Path\n    size_bytes: int\n    @property\n    def size_mb(self) -> float:\n        return self.size_bytes / (1024 * 1024)\ndef iter_assets(root: Path, min_bytes: int) -> Iterable[Asset]:\n    for path in root.rglob(\"*\"):",
        "detail": "scripts.report_large_assets",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "def main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1\n    try:\n        payload = json.loads(DATA_FILE.read_text(encoding=\"utf-8\"))\n    except json.JSONDecodeError as exc:\n        print(f\"❌ Invalid JSON: {exc}\", file=sys.stderr)\n        return 1\n    if not isinstance(payload, list):",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "is_remote_url",
        "kind": 2,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "def is_remote_url(value: str) -> bool:\n    parsed = urlparse(value)\n    return parsed.scheme in {\"http\", \"https\"}\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "ROOT = Path(__file__).resolve().parents[1]\nDATA_FILE = ROOT / \"docs\" / \"data\" / \"courses.json\"\nDOCS_ROOT = ROOT / \"docs\"\nREQUIRED_FIELDS = {\"id\", \"title\", \"grade\", \"description\", \"resources\"}\nRESOURCE_FIELDS = {\"id\", \"label\", \"href\", \"kind\"}\nALLOWED_KINDS = {\"pdf\", \"ppt\", \"html\"}\ndef main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "DATA_FILE",
        "kind": 5,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "DATA_FILE = ROOT / \"docs\" / \"data\" / \"courses.json\"\nDOCS_ROOT = ROOT / \"docs\"\nREQUIRED_FIELDS = {\"id\", \"title\", \"grade\", \"description\", \"resources\"}\nRESOURCE_FIELDS = {\"id\", \"label\", \"href\", \"kind\"}\nALLOWED_KINDS = {\"pdf\", \"ppt\", \"html\"}\ndef main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1\n    try:",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "DOCS_ROOT",
        "kind": 5,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "DOCS_ROOT = ROOT / \"docs\"\nREQUIRED_FIELDS = {\"id\", \"title\", \"grade\", \"description\", \"resources\"}\nRESOURCE_FIELDS = {\"id\", \"label\", \"href\", \"kind\"}\nALLOWED_KINDS = {\"pdf\", \"ppt\", \"html\"}\ndef main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1\n    try:\n        payload = json.loads(DATA_FILE.read_text(encoding=\"utf-8\"))",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "REQUIRED_FIELDS",
        "kind": 5,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "REQUIRED_FIELDS = {\"id\", \"title\", \"grade\", \"description\", \"resources\"}\nRESOURCE_FIELDS = {\"id\", \"label\", \"href\", \"kind\"}\nALLOWED_KINDS = {\"pdf\", \"ppt\", \"html\"}\ndef main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1\n    try:\n        payload = json.loads(DATA_FILE.read_text(encoding=\"utf-8\"))\n    except json.JSONDecodeError as exc:",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "RESOURCE_FIELDS",
        "kind": 5,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "RESOURCE_FIELDS = {\"id\", \"label\", \"href\", \"kind\"}\nALLOWED_KINDS = {\"pdf\", \"ppt\", \"html\"}\ndef main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1\n    try:\n        payload = json.loads(DATA_FILE.read_text(encoding=\"utf-8\"))\n    except json.JSONDecodeError as exc:\n        print(f\"❌ Invalid JSON: {exc}\", file=sys.stderr)",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "ALLOWED_KINDS",
        "kind": 5,
        "importPath": "scripts.validate_courses",
        "description": "scripts.validate_courses",
        "peekOfCode": "ALLOWED_KINDS = {\"pdf\", \"ppt\", \"html\"}\ndef main() -> int:\n    if not DATA_FILE.exists():\n        print(f\"❌ Missing data file: {DATA_FILE}\", file=sys.stderr)\n        return 1\n    try:\n        payload = json.loads(DATA_FILE.read_text(encoding=\"utf-8\"))\n    except json.JSONDecodeError as exc:\n        print(f\"❌ Invalid JSON: {exc}\", file=sys.stderr)\n        return 1",
        "detail": "scripts.validate_courses",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-01-hello",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-01-hello",
        "peekOfCode": "comm = MPI.COMM_WORLD\nname = MPI.Get_processor_name()\nsys.stdout.write(\"Hello World!\")\nsys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-01-hello",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-01-hello",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-01-hello",
        "peekOfCode": "name = MPI.Get_processor_name()\nsys.stdout.write(\"Hello World!\")\nsys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-01-hello",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.size\nrank = comm.rank\nname = MPI.Get_processor_name()\nshared = 3.14\nif rank == 0:\n    data = shared\n    comm.send(data, dest=1)\n    comm.send(data, dest=2)\n    sys.stdout.write(\"From rank %s, we sent %f\\n\" %(rank, data))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "peekOfCode": "size = comm.size\nrank = comm.rank\nname = MPI.Get_processor_name()\nshared = 3.14\nif rank == 0:\n    data = shared\n    comm.send(data, dest=1)\n    comm.send(data, dest=2)\n    sys.stdout.write(\"From rank %s, we sent %f\\n\" %(rank, data))\n    time.sleep(5)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "peekOfCode": "rank = comm.rank\nname = MPI.Get_processor_name()\nshared = 3.14\nif rank == 0:\n    data = shared\n    comm.send(data, dest=1)\n    comm.send(data, dest=2)\n    sys.stdout.write(\"From rank %s, we sent %f\\n\" %(rank, data))\n    time.sleep(5)\nelif rank == 1:",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "peekOfCode": "name = MPI.Get_processor_name()\nshared = 3.14\nif rank == 0:\n    data = shared\n    comm.send(data, dest=1)\n    comm.send(data, dest=2)\n    sys.stdout.write(\"From rank %s, we sent %f\\n\" %(rank, data))\n    time.sleep(5)\nelif rank == 1:\n    data = comm.recv(source=0)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "documentation": {}
    },
    {
        "label": "shared",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "peekOfCode": "shared = 3.14\nif rank == 0:\n    data = shared\n    comm.send(data, dest=1)\n    comm.send(data, dest=2)\n    sys.stdout.write(\"From rank %s, we sent %f\\n\" %(rank, data))\n    time.sleep(5)\nelif rank == 1:\n    data = comm.recv(source=0)\n    sys.stdout.write(\"On rank %s, we received %f\\n\" %(rank, data))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-02-shared",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.size\nrank = comm.rank\nname = MPI.Get_processor_name()\nif rank == 0:\n    sys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))\n    shared1 = {'d1': 55, 'd2': 42}\n    comm.send(shared1, dest=1, tag=1)\n    shared2 = {'d3': 25, 'd4': 22}\n    comm.send(shared2, dest=1, tag=2)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "peekOfCode": "size = comm.size\nrank = comm.rank\nname = MPI.Get_processor_name()\nif rank == 0:\n    sys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))\n    shared1 = {'d1': 55, 'd2': 42}\n    comm.send(shared1, dest=1, tag=1)\n    shared2 = {'d3': 25, 'd4': 22}\n    comm.send(shared2, dest=1, tag=2)\nif rank == 1:",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "peekOfCode": "rank = comm.rank\nname = MPI.Get_processor_name()\nif rank == 0:\n    sys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))\n    shared1 = {'d1': 55, 'd2': 42}\n    comm.send(shared1, dest=1, tag=1)\n    shared2 = {'d3': 25, 'd4': 22}\n    comm.send(shared2, dest=1, tag=2)\nif rank == 1:\n    sys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "peekOfCode": "name = MPI.Get_processor_name()\nif rank == 0:\n    sys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))\n    shared1 = {'d1': 55, 'd2': 42}\n    comm.send(shared1, dest=1, tag=1)\n    shared2 = {'d3': 25, 'd4': 22}\n    comm.send(shared2, dest=1, tag=2)\nif rank == 1:\n    sys.stdout.write(\"Name: %s, My rank is %d\\n\" % (name, comm.rank))\n    receive1 = comm.recv(source=0, tag=1)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-03-2SendRecv",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.rank\nif rank == 0:\n    data = {'a': 1, 'b': 2, 'c': 3}\nelse:\n    data = None\ndata = comm.bcast(data, root=0)\nsys.stdout.write(\"Rank: %d, Data: %d, %d, %d\\n\"\n                 % (rank, data['a'], data['b'], data['c']))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "peekOfCode": "rank = comm.rank\nif rank == 0:\n    data = {'a': 1, 'b': 2, 'c': 3}\nelse:\n    data = None\ndata = comm.bcast(data, root=0)\nsys.stdout.write(\"Rank: %d, Data: %d, %d, %d\\n\"\n                 % (rank, data['a'], data['b'], data['c']))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "peekOfCode": "data = comm.bcast(data, root=0)\nsys.stdout.write(\"Rank: %d, Data: %d, %d, %d\\n\"\n                 % (rank, data['a'], data['b'], data['c']))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-Broadcast",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.size\n# rank = comm.rank\nname = MPI.Get_processor_name()\n# sys.stdout.write(comm.Get_rank().__str__()+\"\\n\")\nfor i in range(5):\n    sys.stdout.write(\"Process: %d: %d \\n\" % (comm.Get_rank(), i))\n    sys.stdout.write(\"Waiting ...... \\n\")\ncomm.Barrier()\nfor i in range(5, 10, 1):",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "peekOfCode": "size = comm.size\n# rank = comm.rank\nname = MPI.Get_processor_name()\n# sys.stdout.write(comm.Get_rank().__str__()+\"\\n\")\nfor i in range(5):\n    sys.stdout.write(\"Process: %d: %d \\n\" % (comm.Get_rank(), i))\n    sys.stdout.write(\"Waiting ...... \\n\")\ncomm.Barrier()\nfor i in range(5, 10, 1):\n    sys.stdout.write(\"Process: %d: %d \\n\" % (comm.Get_rank(), i))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "peekOfCode": "name = MPI.Get_processor_name()\n# sys.stdout.write(comm.Get_rank().__str__()+\"\\n\")\nfor i in range(5):\n    sys.stdout.write(\"Process: %d: %d \\n\" % (comm.Get_rank(), i))\n    sys.stdout.write(\"Waiting ...... \\n\")\ncomm.Barrier()\nfor i in range(5, 10, 1):\n    sys.stdout.write(\"Process: %d: %d \\n\" % (comm.Get_rank(), i))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrier",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierFlushPrt",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierFlushPrt",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nif rank == 0:\n    sleep(2)\n    print(\"head finished sleeping\",  flush=True)\ncomm.Barrier()\nsleep(random.uniform(0, 2))\nprint(rank, 'finished sleeping ',  flush=True)\ncomm.Barrier()\nif rank == 0:",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierFlushPrt",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierFlushPrt",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierFlushPrt",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    sleep(2)\n    print(\"head finished sleeping\",  flush=True)\ncomm.Barrier()\nsleep(random.uniform(0, 2))\nprint(rank, 'finished sleeping ',  flush=True)\ncomm.Barrier()\nif rank == 0:\n    print(\"All done!\",  flush=True)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierFlushPrt",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierNoFlushPrt",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierNoFlushPrt",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nif rank == 0:\n    sleep(2)\n    print(\"head finished sleeping\")\ncomm.Barrier()\nsleep(random.uniform(0, 2))\nprint(rank, 'finished sleeping ')\ncomm.Barrier()\nif rank == 0:",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierNoFlushPrt",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierNoFlushPrt",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierNoFlushPrt",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    sleep(2)\n    print(\"head finished sleeping\")\ncomm.Barrier()\nsleep(random.uniform(0, 2))\nprint(rank, 'finished sleeping ')\ncomm.Barrier()\nif rank == 0:\n    print(\"All done!\")",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-04-barrierNoFlushPrt",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.Get_size()\nrank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    sys.stdout.write(\"We will be scattering: \")\n    sys.stdout.write(\" \".join(str(x) for x in data))\n    sys.stdout.write(\"\\n\")\nelse:\n    data = None",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "peekOfCode": "size = comm.Get_size()\nrank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    sys.stdout.write(\"We will be scattering: \")\n    sys.stdout.write(\" \".join(str(x) for x in data))\n    sys.stdout.write(\"\\n\")\nelse:\n    data = None\ndata = comm.scatter(data, root=0)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    sys.stdout.write(\"We will be scattering: \")\n    sys.stdout.write(\" \".join(str(x) for x in data))\n    sys.stdout.write(\"\\n\")\nelse:\n    data = None\ndata = comm.scatter(data, root=0)\nsys.stdout.write(\"Rank: %d has data: %d\\n\" % (rank, data))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "peekOfCode": "data = comm.scatter(data, root=0)\nsys.stdout.write(\"Rank: %d has data: %d\\n\" % (rank, data))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-05-scatter",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.Get_size()\nrank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    sys.stdout.write(\"We will be scattering: \")\n    sys.stdout.write(\" \".join(str(x) for x in data))\n    sys.stdout.write(\"\\n\")\nelse:\n    data = None",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "peekOfCode": "size = comm.Get_size()\nrank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    sys.stdout.write(\"We will be scattering: \")\n    sys.stdout.write(\" \".join(str(x) for x in data))\n    sys.stdout.write(\"\\n\")\nelse:\n    data = None\ndata = comm.scatter(data, root=0)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    sys.stdout.write(\"We will be scattering: \")\n    sys.stdout.write(\" \".join(str(x) for x in data))\n    sys.stdout.write(\"\\n\")\nelse:\n    data = None\ndata = comm.scatter(data, root=0)\nsys.stdout.write(\"Rank: %d has data: %d\\n\" % (rank, data))",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "peekOfCode": "data = comm.scatter(data, root=0)\nsys.stdout.write(\"Rank: %d has data: %d\\n\" % (rank, data))\ndata *= data\nnewData = comm.gather(data, root=0)\nif rank == 0:\n    sys.stdout.write(\"We have gathered: \")\n    sys.stdout.write(\" \".join(str(x) for x in newData))\n    sys.stdout.write(\"\\n\")",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "documentation": {}
    },
    {
        "label": "newData",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "peekOfCode": "newData = comm.gather(data, root=0)\nif rank == 0:\n    sys.stdout.write(\"We have gathered: \")\n    sys.stdout.write(\" \".join(str(x) for x in newData))\n    sys.stdout.write(\"\\n\")",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gather",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.Get_size()\nrank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    print(\"Rank %d will be scattering: \" % rank, flush=True)\n    print(\" \".join(str(x) for x in data), flush=True)\n    # print(\"\\n\", flush=True)\nelse:\n    data = None",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "peekOfCode": "size = comm.Get_size()\nrank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    print(\"Rank %d will be scattering: \" % rank, flush=True)\n    print(\" \".join(str(x) for x in data), flush=True)\n    # print(\"\\n\", flush=True)\nelse:\n    data = None\ndata = comm.scatter(data, root=0)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = [x for x in range(0, size)]\n    print(\"Rank %d will be scattering: \" % rank, flush=True)\n    print(\" \".join(str(x) for x in data), flush=True)\n    # print(\"\\n\", flush=True)\nelse:\n    data = None\ndata = comm.scatter(data, root=0)\n# print(\"Rank %d has data %d\\n\" % (rank, data), flush=True)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "peekOfCode": "data = comm.scatter(data, root=0)\n# print(\"Rank %d has data %d\\n\" % (rank, data), flush=True)\nprint(\"Rank %d has data %d\" % (rank, data), flush=True)\ndata *= data\nnewData = comm.gather(data, root=0)\nif rank == 0:\n    print(\"Rank %d will be scattering: \" % rank, flush=True)\n    print(\" \".join(str(x) for x in newData), flush=True)\n    # print(\"\\n\", flush=True)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "documentation": {}
    },
    {
        "label": "newData",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "peekOfCode": "newData = comm.gather(data, root=0)\nif rank == 0:\n    print(\"Rank %d will be scattering: \" % rank, flush=True)\n    print(\" \".join(str(x) for x in newData), flush=True)\n    # print(\"\\n\", flush=True)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-06-gatherBarrier",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-07-isendrecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-07-isendrecv",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nif rank == 0:\n    data = {'a': 7, 'b':3.14}\n    req = comm.isend(data, dest = 1, tag = 11)\n    req.wait()\n    sys.stdout.write(\"Sent %d and %f from rank 0.\\n\"\n                     % (data['a'], data['b']))\nelif rank == 1:\n    req = comm.irecv(source = 0, tag = 11)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-07-isendrecv",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-07-isendrecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-07-isendrecv",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = {'a': 7, 'b':3.14}\n    req = comm.isend(data, dest = 1, tag = 11)\n    req.wait()\n    sys.stdout.write(\"Sent %d and %f from rank 0.\\n\"\n                     % (data['a'], data['b']))\nelif rank == 1:\n    req = comm.irecv(source = 0, tag = 11)\n    data = req.wait()",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-07-isendrecv",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-08-taggedSendRecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-08-taggedSendRecv",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nif rank == 0:\n    data = np.arange(100, dtype=np.float64)\n    comm.Send(data, dest=1, tag=13)\n    sys.stdout.write(\"Sent NumPy data from rank 0.\\n\")\nelif rank == 1:\n    data = np.empty(100, dtype=np.float64)\n    comm.Recv(data, source=0, tag=13)\n    sys.stdout.write(\"Received NumPy data at rank 1.\\n\")",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-08-taggedSendRecv",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-08-taggedSendRecv",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-08-taggedSendRecv",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = np.arange(100, dtype=np.float64)\n    comm.Send(data, dest=1, tag=13)\n    sys.stdout.write(\"Sent NumPy data from rank 0.\\n\")\nelif rank == 1:\n    data = np.empty(100, dtype=np.float64)\n    comm.Recv(data, source=0, tag=13)\n    sys.stdout.write(\"Received NumPy data at rank 1.\\n\")",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-08-taggedSendRecv",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\ncartesian3d = comm.Create_cart(dims=[2, 2, 2], periods=[False, False, False], reorder=False)\ncoord3d = cartesian3d.Get_coords(rank)\nprint(\"In 3D topology, Processor \", rank, \" has coordinates \", coord3d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "peekOfCode": "rank = comm.Get_rank()\ncartesian3d = comm.Create_cart(dims=[2, 2, 2], periods=[False, False, False], reorder=False)\ncoord3d = cartesian3d.Get_coords(rank)\nprint(\"In 3D topology, Processor \", rank, \" has coordinates \", coord3d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "documentation": {}
    },
    {
        "label": "cartesian3d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "peekOfCode": "cartesian3d = comm.Create_cart(dims=[2, 2, 2], periods=[False, False, False], reorder=False)\ncoord3d = cartesian3d.Get_coords(rank)\nprint(\"In 3D topology, Processor \", rank, \" has coordinates \", coord3d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "documentation": {}
    },
    {
        "label": "coord3d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "peekOfCode": "coord3d = cartesian3d.Get_coords(rank)\nprint(\"In 3D topology, Processor \", rank, \" has coordinates \", coord3d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\ncartesian3d = comm.Create_cart(dims=[2, 2, 2], periods=[False, False, False], reorder=False)\ncoord3d = cartesian3d.Get_coords(rank)\n#Create a sub-communicator that is a 2X2 plane\ncartesian2d = cartesian3d.Sub(remain_dims=[False,True,True])\nrank2d = cartesian2d.Get_rank()\ncoord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "rank = comm.Get_rank()\ncartesian3d = comm.Create_cart(dims=[2, 2, 2], periods=[False, False, False], reorder=False)\ncoord3d = cartesian3d.Get_coords(rank)\n#Create a sub-communicator that is a 2X2 plane\ncartesian2d = cartesian3d.Sub(remain_dims=[False,True,True])\nrank2d = cartesian2d.Get_rank()\ncoord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "cartesian3d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "cartesian3d = comm.Create_cart(dims=[2, 2, 2], periods=[False, False, False], reorder=False)\ncoord3d = cartesian3d.Get_coords(rank)\n#Create a sub-communicator that is a 2X2 plane\ncartesian2d = cartesian3d.Sub(remain_dims=[False,True,True])\nrank2d = cartesian2d.Get_rank()\ncoord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "coord3d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "coord3d = cartesian3d.Get_coords(rank)\n#Create a sub-communicator that is a 2X2 plane\ncartesian2d = cartesian3d.Sub(remain_dims=[False,True,True])\nrank2d = cartesian2d.Get_rank()\ncoord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "cartesian2d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "cartesian2d = cartesian3d.Sub(remain_dims=[False,True,True])\nrank2d = cartesian2d.Get_rank()\ncoord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "rank2d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "rank2d = cartesian2d.Get_rank()\ncoord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "coord2d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "description": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "peekOfCode": "coord2d = cartesian2d.Get_coords(rank2d)\nprint(\"In 2D topology, Processor \", rank, \"  has coordinates \", coord2d)",
        "detail": "大规模计算(updating).code.RaspberryPi.RaspberryPi.mpi4py-09-topology2D",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.fib_py",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.fib_py",
        "peekOfCode": "def fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-2) + fibonacci(n-1)\n@lru_cache(maxsize=None)\ndef fibonacci_cached(n):\n    if n < 2:\n        return n\n    return fibonacci_cached(n-2) + fibonacci_cached(n-1)",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.fib_py",
        "documentation": {}
    },
    {
        "label": "fibonacci_cached",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.fib_py",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.fib_py",
        "peekOfCode": "def fibonacci_cached(n):\n    if n < 2:\n        return n\n    return fibonacci_cached(n-2) + fibonacci_cached(n-1)",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.fib_py",
        "documentation": {}
    },
    {
        "label": "ext",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.setup",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.setup",
        "peekOfCode": "ext = Extension(\"fib\",\n                sources=[\"fib.pyx\"],\n               )\nsetup(\n     ext_modules=cythonize(ext)\n)",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.setup",
        "documentation": {}
    },
    {
        "label": "ncython",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "ncython = 100\nnpython = 10\nncached = 10000000\n# Pure Python\ntime_python = repeat(\"fibonacci_py(30)\", number=npython, globals=locals())\ntime_python = min(time_python) / npython\n# Cython\ntime_cython = repeat(\"fibonacci(30)\", number=ncython, globals=locals())\ntime_cython = min(time_cython) / ncython\n# Python, cached",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "npython",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "npython = 10\nncached = 10000000\n# Pure Python\ntime_python = repeat(\"fibonacci_py(30)\", number=npython, globals=locals())\ntime_python = min(time_python) / npython\n# Cython\ntime_cython = repeat(\"fibonacci(30)\", number=ncython, globals=locals())\ntime_cython = min(time_cython) / ncython\n# Python, cached\ntime_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "ncached",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "ncached = 10000000\n# Pure Python\ntime_python = repeat(\"fibonacci_py(30)\", number=npython, globals=locals())\ntime_python = min(time_python) / npython\n# Cython\ntime_cython = repeat(\"fibonacci(30)\", number=ncython, globals=locals())\ntime_cython = min(time_cython) / ncython\n# Python, cached\ntime_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())\ntime_cached = min(time_cached) / ncached",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "time_python",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "time_python = repeat(\"fibonacci_py(30)\", number=npython, globals=locals())\ntime_python = min(time_python) / npython\n# Cython\ntime_cython = repeat(\"fibonacci(30)\", number=ncython, globals=locals())\ntime_cython = min(time_cython) / ncython\n# Python, cached\ntime_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())\ntime_cached = min(time_cached) / ncached\nprint(\"Pure Python:          {:5.4f} s\".format(time_python))\nprint(\"Cython:               {:5.4f} ms\".format(time_cython*1.e3))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "time_python",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "time_python = min(time_python) / npython\n# Cython\ntime_cython = repeat(\"fibonacci(30)\", number=ncython, globals=locals())\ntime_cython = min(time_cython) / ncython\n# Python, cached\ntime_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())\ntime_cached = min(time_cached) / ncached\nprint(\"Pure Python:          {:5.4f} s\".format(time_python))\nprint(\"Cython:               {:5.4f} ms\".format(time_cython*1.e3))\nprint(\"Speedup:              {:5.1f}\".format(time_python / time_cython))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "time_cython",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "time_cython = repeat(\"fibonacci(30)\", number=ncython, globals=locals())\ntime_cython = min(time_cython) / ncython\n# Python, cached\ntime_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())\ntime_cached = min(time_cached) / ncached\nprint(\"Pure Python:          {:5.4f} s\".format(time_python))\nprint(\"Cython:               {:5.4f} ms\".format(time_cython*1.e3))\nprint(\"Speedup:              {:5.1f}\".format(time_python / time_cython))\nprint(\"Pure Python cached:   {:5.4f} us\".format(time_cached*1.e6))\nprint(\"Speedup over Cython:  {:5.1e}\".format(time_cython / time_cached))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "time_cython",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "time_cython = min(time_cython) / ncython\n# Python, cached\ntime_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())\ntime_cached = min(time_cached) / ncached\nprint(\"Pure Python:          {:5.4f} s\".format(time_python))\nprint(\"Cython:               {:5.4f} ms\".format(time_cython*1.e3))\nprint(\"Speedup:              {:5.1f}\".format(time_python / time_cython))\nprint(\"Pure Python cached:   {:5.4f} us\".format(time_cached*1.e6))\nprint(\"Speedup over Cython:  {:5.1e}\".format(time_cython / time_cached))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "time_cached",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "time_cached = repeat(\"fibonacci_cached(30)\", number=ncached, globals=locals())\ntime_cached = min(time_cached) / ncached\nprint(\"Pure Python:          {:5.4f} s\".format(time_python))\nprint(\"Cython:               {:5.4f} ms\".format(time_cython*1.e3))\nprint(\"Speedup:              {:5.1f}\".format(time_python / time_cython))\nprint(\"Pure Python cached:   {:5.4f} us\".format(time_cached*1.e6))\nprint(\"Speedup over Cython:  {:5.1e}\".format(time_cython / time_cached))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "time_cached",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "peekOfCode": "time_cached = min(time_cached) / ncached\nprint(\"Pure Python:          {:5.4f} s\".format(time_python))\nprint(\"Cython:               {:5.4f} ms\".format(time_cython*1.e3))\nprint(\"Speedup:              {:5.1f}\".format(time_python / time_cython))\nprint(\"Pure Python cached:   {:5.4f} us\".format(time_cached*1.e6))\nprint(\"Speedup over Cython:  {:5.1e}\".format(time_cython / time_cached))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.solution.test_fib",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.c-functions.fib",
        "description": "大规模计算(updating).code.hpc-python-master.cython.c-functions.fib",
        "peekOfCode": "def fibonacci(n):\n    if n < 2:\n        return n\n    return fibonacci(n-2) + fibonacci(n-1)",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.c-functions.fib",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.solution.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.solution.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.solution.heat_main",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            u[i, j] = u_previous[i, j] + a * dt * ( \\",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.cython.heat-equation.heat_main",
        "documentation": {}
    },
    {
        "label": "kernel",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel",
        "description": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel",
        "peekOfCode": "def kernel(zr, zi, cr, ci, lim, cutoff):\n    ''' Computes the number of iterations `n` such that \n        |z_n| > `lim`, where `z_n = z_{n-1}**2 + c`.\n    '''\n    count = 0\n    while ((zr*zr + zi*zi) < (lim*lim)) and count < cutoff:\n        zr, zi = zr * zr - zi * zi + cr, 2 * zr * zi + ci\n        count += 1\n    return count\ndef compute_mandel(cr, ci, N, bound=1.5, lim=1000., cutoff=1e6):",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel",
        "documentation": {}
    },
    {
        "label": "compute_mandel",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel",
        "description": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel",
        "peekOfCode": "def compute_mandel(cr, ci, N, bound=1.5, lim=1000., cutoff=1e6):\n    mandel = np.empty((N, N), dtype=int)\n    grid_x = np.linspace(-bound, bound, N)\n    t0 = time()\n    for i, x in enumerate(grid_x):\n        for j, y in enumerate(grid_x):\n            mandel[i,j] = kernel(x, y, cr, ci, lim, cutoff)\n    return mandel, time() - t0",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel",
        "documentation": {}
    },
    {
        "label": "plot_mandel",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel_main",
        "description": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel_main",
        "peekOfCode": "def plot_mandel(mandel):\n    plt.imshow(mandel)\n    plt.axis('off')\n    plt.show()\ndef main(version='py'):\n    kwargs = dict(cr=0.285, ci=0.01,\n                  N=200,\n                  bound=1.5)\n    # choose pure Python or Cython version\n    if version == 'py':",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel_main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel_main",
        "description": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel_main",
        "peekOfCode": "def main(version='py'):\n    kwargs = dict(cr=0.285, ci=0.01,\n                  N=200,\n                  bound=1.5)\n    # choose pure Python or Cython version\n    if version == 'py':\n        print(\"Using pure Python\")\n        mandel_func = compute_mandel_py\n    elif version == 'cyt': \n        print(\"Using Cython\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.cython.mandel_main",
        "documentation": {}
    },
    {
        "label": "ffi",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "peekOfCode": "ffi = FFI()\nlib = ffi.dlopen('./libmyclib.so')\nffi.cdef(\"\"\"\n            void add(double *, double *, int);\n            void subtract(double *, double *, int);\n         \"\"\")\na = np.random.random(10)\nb = np.ones_like(a)\n# \"pointer\" objects\naptr = ffi.cast(\"double *\", ffi.from_buffer(a))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "documentation": {}
    },
    {
        "label": "lib",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "peekOfCode": "lib = ffi.dlopen('./libmyclib.so')\nffi.cdef(\"\"\"\n            void add(double *, double *, int);\n            void subtract(double *, double *, int);\n         \"\"\")\na = np.random.random(10)\nb = np.ones_like(a)\n# \"pointer\" objects\naptr = ffi.cast(\"double *\", ffi.from_buffer(a))\nbptr = ffi.cast(\"double *\", ffi.from_buffer(b))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "peekOfCode": "a = np.random.random(10)\nb = np.ones_like(a)\n# \"pointer\" objects\naptr = ffi.cast(\"double *\", ffi.from_buffer(a))\nbptr = ffi.cast(\"double *\", ffi.from_buffer(b))\nprint(\"a:\", a)\nprint(\"b:\", b)\nlib.add(aptr, bptr, len(a))\nprint(\"a + b\", a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "peekOfCode": "b = np.ones_like(a)\n# \"pointer\" objects\naptr = ffi.cast(\"double *\", ffi.from_buffer(a))\nbptr = ffi.cast(\"double *\", ffi.from_buffer(b))\nprint(\"a:\", a)\nprint(\"b:\", b)\nlib.add(aptr, bptr, len(a))\nprint(\"a + b\", a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "documentation": {}
    },
    {
        "label": "aptr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "peekOfCode": "aptr = ffi.cast(\"double *\", ffi.from_buffer(a))\nbptr = ffi.cast(\"double *\", ffi.from_buffer(b))\nprint(\"a:\", a)\nprint(\"b:\", b)\nlib.add(aptr, bptr, len(a))\nprint(\"a + b\", a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "documentation": {}
    },
    {
        "label": "bptr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "peekOfCode": "bptr = ffi.cast(\"double *\", ffi.from_buffer(b))\nprint(\"a:\", a)\nprint(\"b:\", b)\nlib.add(aptr, bptr, len(a))\nprint(\"a + b\", a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.cffi.example",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.fortran.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.fortran.example",
        "peekOfCode": "a = np.random.random(10)\nb = np.ones_like(a)\nprint(a)\nadd.add(a, b)\nprint(a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.fortran.example",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.interface.fortran.example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.interface.fortran.example",
        "peekOfCode": "b = np.ones_like(a)\nprint(a)\nadd.add(a, b)\nprint(a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.interface.fortran.example",
        "documentation": {}
    },
    {
        "label": "atoms",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.gpaw.c6h6",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.gpaw.c6h6",
        "peekOfCode": "atoms = molecule('C6H6')\natoms.center(3.5)\ncalc = GPAW(h=0.2, xc='PBE', txt='benzene.txt')\natoms.set_calculator(calc)\ncProfile.run(\"atoms.get_potential_energy()\", \"gpaw.prof\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.gpaw.c6h6",
        "documentation": {}
    },
    {
        "label": "calc",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.gpaw.c6h6",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.gpaw.c6h6",
        "peekOfCode": "calc = GPAW(h=0.2, xc='PBE', txt='benzene.txt')\natoms.set_calculator(calc)\ncProfile.run(\"atoms.get_potential_energy()\", \"gpaw.prof\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.gpaw.c6h6",
        "documentation": {}
    },
    {
        "label": "multiply",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.matmul",
        "peekOfCode": "def multiply(a, b):\n    n, m = a.shape\n    c = np.zeros_like(a)\n    for i in range(n):\n        for j in range(m):\n            for k in range(m):\n                c[i,j] += a[i, k] * b[k, j]\n    return c",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.matmul",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "a = np.random.random((1000, 1000))\nb = np.random.random((1000, 1000))\nnnumpy = 100\ntime_numpy = repeat(\"c = np.dot(a, b)\", number=nnumpy, globals=locals())\ntime_numpy = min(time_numpy) / nnumpy\nprint(\"Time with numpy.dot:  {:5.3f} s\".format(time_numpy))\nnpython = 1\ntime_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "b = np.random.random((1000, 1000))\nnnumpy = 100\ntime_numpy = repeat(\"c = np.dot(a, b)\", number=nnumpy, globals=locals())\ntime_numpy = min(time_numpy) / nnumpy\nprint(\"Time with numpy.dot:  {:5.3f} s\".format(time_numpy))\nnpython = 1\ntime_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "nnumpy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "nnumpy = 100\ntime_numpy = repeat(\"c = np.dot(a, b)\", number=nnumpy, globals=locals())\ntime_numpy = min(time_numpy) / nnumpy\nprint(\"Time with numpy.dot:  {:5.3f} s\".format(time_numpy))\nnpython = 1\ntime_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "time_numpy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "time_numpy = repeat(\"c = np.dot(a, b)\", number=nnumpy, globals=locals())\ntime_numpy = min(time_numpy) / nnumpy\nprint(\"Time with numpy.dot:  {:5.3f} s\".format(time_numpy))\nnpython = 1\ntime_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "time_numpy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "time_numpy = min(time_numpy) / nnumpy\nprint(\"Time with numpy.dot:  {:5.3f} s\".format(time_numpy))\nnpython = 1\ntime_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "npython",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "npython = 1\ntime_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "time_python",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "peekOfCode": "time_python = repeat(\"c = multiply(a, b)\", number=npython, \n                     repeat=1, globals=locals())\nprint(\"Time with Python:   {:5.3f} s\".format(time_python[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.matmul.test_matmul",
        "documentation": {}
    },
    {
        "label": "kernel",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel",
        "peekOfCode": "def kernel(zr, zi, cr, ci, lim, cutoff):\n    ''' Computes the number of iterations `n` such that \n        |z_n| > `lim`, where `z_n = z_{n-1}**2 + c`.\n    '''\n    count = 0\n    while ((zr*zr + zi*zi) < (lim*lim)) and count < cutoff:\n        zr, zi = zr * zr - zi * zi + cr, 2 * zr * zi + ci\n        count += 1\n    return count\ndef compute_mandel(cr, ci, N, bound=1.5, lim=1000., cutoff=1e6):",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel",
        "documentation": {}
    },
    {
        "label": "compute_mandel",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel",
        "peekOfCode": "def compute_mandel(cr, ci, N, bound=1.5, lim=1000., cutoff=1e6):\n    mandel = np.empty((N, N), dtype=int)\n    grid_x = np.linspace(-bound, bound, N)\n    t0 = time()\n    for i, x in enumerate(grid_x):\n        for j, y in enumerate(grid_x):\n            mandel[i,j] = kernel(x, y, cr, ci, lim, cutoff)\n    return mandel, time() - t0",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel",
        "documentation": {}
    },
    {
        "label": "plot_mandel",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel_main",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel_main",
        "peekOfCode": "def plot_mandel(mandel):\n    plt.imshow(mandel)\n    plt.axis('off')\n    plt.show()\ndef main(version='py'):\n    kwargs = dict(cr=0.285, ci=0.01,\n                  N=200,\n                  bound=1.5)\n    # choose pure Python or Cython version\n    if version == 'py':",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel_main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel_main",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel_main",
        "peekOfCode": "def main(version='py'):\n    kwargs = dict(cr=0.285, ci=0.01,\n                  N=200,\n                  bound=1.5)\n    # choose pure Python or Cython version\n    if version == 'py':\n        print(\"Using pure Python\")\n        mandel_func = compute_mandel_py\n    elif version == 'cyt': \n        print(\"Using Cython\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.mandel_main",
        "documentation": {}
    },
    {
        "label": "Timer",
        "kind": 6,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "peekOfCode": "class Timer:\n    def __enter__(self):\n        self.start = time.process_time()\n        return self\n    def __exit__(self, *args):\n        self.end = time.process_time()\n        self.interval = self.end - self.start\ndef calculate(a):\n    result = np.exp(a) * np.sin(a)\n    return result",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "documentation": {}
    },
    {
        "label": "calculate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "peekOfCode": "def calculate(a):\n    result = np.exp(a) * np.sin(a)\n    return result\nx = np.random.random((100, 100))\nwith Timer() as t:\n    for r in range(1000):\n        calculate(x)\nprint(\"Time spent\", t.interval)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "peekOfCode": "x = np.random.random((100, 100))\nwith Timer() as t:\n    for r in range(1000):\n        calculate(x)\nprint(\"Time spent\", t.interval)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing-with",
        "documentation": {}
    },
    {
        "label": "calculate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "peekOfCode": "def calculate(a):\n    result = np.exp(a) * np.sin(a)\n    return result\nx = np.random.random((100, 100))\nt0 = perf_counter()\nfor r in range(1000):\n    calculate(x)\nt1 = perf_counter()\nprint(\"Time spent\", t1 - t0)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "peekOfCode": "x = np.random.random((100, 100))\nt0 = perf_counter()\nfor r in range(1000):\n    calculate(x)\nt1 = perf_counter()\nprint(\"Time spent\", t1 - t0)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "peekOfCode": "t0 = perf_counter()\nfor r in range(1000):\n    calculate(x)\nt1 = perf_counter()\nprint(\"Time spent\", t1 - t0)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "documentation": {}
    },
    {
        "label": "t1",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "description": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "peekOfCode": "t1 = perf_counter()\nprint(\"Time spent\", t1 - t0)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.performance.timing",
        "documentation": {}
    },
    {
        "label": "a1",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "description": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "peekOfCode": "a1 = np.random.random((10,3))\nb1 = np.array((1, 2, 3))\nc1 = a1 + b1\nprint a1, b1\nprint c1",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "description": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "peekOfCode": "b1 = np.array((1, 2, 3))\nc1 = a1 + b1\nprint a1, b1\nprint c1",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "documentation": {}
    },
    {
        "label": "c1",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "description": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "peekOfCode": "c1 = a1 + b1\nprint a1, b1\nprint c1",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.broadcasting",
        "documentation": {}
    },
    {
        "label": "hello",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.lock",
        "description": "大规模计算(updating).code.hpc-python-master.demos.lock",
        "peekOfCode": "def hello(lock, id):\n    lock.acquire()\n    time.sleep(random.uniform(1, id % 4))\n    print('Hello world! My ID is {0}'.format(id))\n    lock.release()\nlock = Lock()\nfor i in range(10):\n    Process(target=hello, args=[lock, i]).start()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.lock",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.lock",
        "description": "大规模计算(updating).code.hpc-python-master.demos.lock",
        "peekOfCode": "lock = Lock()\nfor i in range(10):\n    Process(target=hello, args=[lock, i]).start()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.lock",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "description": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "peekOfCode": "def f(x):\n    x['Apple'] = 0.70\n    x['Orange'] = 1.20\nmanager = Manager()\nfruits = manager.dict()\np = Process(target=f, args=[fruits])\np.start()\np.join()\nprint(fruits)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "documentation": {}
    },
    {
        "label": "manager",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "description": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "peekOfCode": "manager = Manager()\nfruits = manager.dict()\np = Process(target=f, args=[fruits])\np.start()\np.join()\nprint(fruits)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "documentation": {}
    },
    {
        "label": "fruits",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "description": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "peekOfCode": "fruits = manager.dict()\np = Process(target=f, args=[fruits])\np.start()\np.join()\nprint(fruits)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "description": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "peekOfCode": "p = Process(target=f, args=[fruits])\np.start()\np.join()\nprint(fruits)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.manager",
        "documentation": {}
    },
    {
        "label": "maxmem",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "def maxmem():\n    # Check maximum memory from /proc/\n    # Based on Python Cookbook\n    # http://code.activestate.com/recipes/286222/\n    # Works on most Linux systems but not in Mac OSX or Windows\n    _scale = {'kB': 1024.0, 'mB': 1024.0 * 1024.0,\n              'KB': 1024.0, 'MB': 1024.0 * 1024.0}\n    _proc_status = '/proc/{0}/status'.format(os.getpid())\n    with open(_proc_status) as f:\n        v = f.read()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "overhead",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "overhead = maxmem()\na = np.random.random((1024, 1024, 10))\nb = np.random.random((1024, 1024, 10))\nc = a - b\n#c = 2.0 * a - 4.5 * b\n#c = 2.0 * a - 4.5 * b + np.sin(a) - np.cos(b)\n#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "a = np.random.random((1024, 1024, 10))\nb = np.random.random((1024, 1024, 10))\nc = a - b\n#c = 2.0 * a - 4.5 * b\n#c = 2.0 * a - 4.5 * b + np.sin(a) - np.cos(b)\n#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "b = np.random.random((1024, 1024, 10))\nc = a - b\n#c = 2.0 * a - 4.5 * b\n#c = 2.0 * a - 4.5 * b + np.sin(a) - np.cos(b)\n#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "c = a - b\n#c = 2.0 * a - 4.5 * b\n#c = 2.0 * a - 4.5 * b + np.sin(a) - np.cos(b)\n#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)\nmem = maxmem() - overhead",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "#c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "#c = 2.0 * a - 4.5 * b\n#c = 2.0 * a - 4.5 * b + np.sin(a) - np.cos(b)\n#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)\nmem = maxmem() - overhead\nprint(\"Size of single array: {0} MB\".format(a.nbytes / 1024.0**2))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "#c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "#c = 2.0 * a - 4.5 * b + np.sin(a) - np.cos(b)\n#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)\nmem = maxmem() - overhead\nprint(\"Size of single array: {0} MB\".format(a.nbytes / 1024.0**2))\nprint(\"Maximum memory: {0:.3f} arrays\".format(mem / a.nbytes))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "#c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "#c = 2.0 * a - 4.5 * b + (np.sin(a) - np.cos(b))\n#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)\nmem = maxmem() - overhead\nprint(\"Size of single array: {0} MB\".format(a.nbytes / 1024.0**2))\nprint(\"Maximum memory: {0:.3f} arrays\".format(mem / a.nbytes))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "#c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "#c = (np.sin(a) - np.cos(b)) + 2.0 * a - 4.5 * b\n#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)\nmem = maxmem() - overhead\nprint(\"Size of single array: {0} MB\".format(a.nbytes / 1024.0**2))\nprint(\"Maximum memory: {0:.3f} arrays\".format(mem / a.nbytes))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "#c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "#c = 2.0 * a\n#c -= 4.5 * b\n#c += np.sin(a)\n#c -= np.cos(b)\nmem = maxmem() - overhead\nprint(\"Size of single array: {0} MB\".format(a.nbytes / 1024.0**2))\nprint(\"Maximum memory: {0:.3f} arrays\".format(mem / a.nbytes))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "mem",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "description": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "peekOfCode": "mem = maxmem() - overhead\nprint(\"Size of single array: {0} MB\".format(a.nbytes / 1024.0**2))\nprint(\"Maximum memory: {0:.3f} arrays\".format(mem / a.nbytes))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.memory_usage",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\ndata = np.arange(8) / 10. + rank\nrecv_buf = np.zeros(8)\n# Python sequence, lenght has to be equal number to MPI tasks\npy_data = []\nfor r in range(4):\n    py_data.append({'key{0:02d}'.format(10*rank + r) : 10*rank + r})",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\ndata = np.arange(8) / 10. + rank\nrecv_buf = np.zeros(8)\n# Python sequence, lenght has to be equal number to MPI tasks\npy_data = []\nfor r in range(4):\n    py_data.append({'key{0:02d}'.format(10*rank + r) : 10*rank + r})\nif rank == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "size = comm.Get_size()\nassert size == 4\ndata = np.arange(8) / 10. + rank\nrecv_buf = np.zeros(8)\n# Python sequence, lenght has to be equal number to MPI tasks\npy_data = []\nfor r in range(4):\n    py_data.append({'key{0:02d}'.format(10*rank + r) : 10*rank + r})\nif rank == 0:\n    print(\"Original data\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "data = np.arange(8) / 10. + rank\nrecv_buf = np.zeros(8)\n# Python sequence, lenght has to be equal number to MPI tasks\npy_data = []\nfor r in range(4):\n    py_data.append({'key{0:02d}'.format(10*rank + r) : 10*rank + r})\nif rank == 0:\n    print(\"Original data\")\ncomm.Barrier()\nfor r in range(size):",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "recv_buf",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "recv_buf = np.zeros(8)\n# Python sequence, lenght has to be equal number to MPI tasks\npy_data = []\nfor r in range(4):\n    py_data.append({'key{0:02d}'.format(10*rank + r) : 10*rank + r})\nif rank == 0:\n    print(\"Original data\")\ncomm.Barrier()\nfor r in range(size):\n    if rank == r:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "py_data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "py_data = []\nfor r in range(4):\n    py_data.append({'key{0:02d}'.format(10*rank + r) : 10*rank + r})\nif rank == 0:\n    print(\"Original data\")\ncomm.Barrier()\nfor r in range(size):\n    if rank == r:\n        print(\"rank \", rank, data)\n        print(\"rank \", rank, py_data)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "new_data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "peekOfCode": "new_data = comm.alltoall(py_data)\ncomm.Barrier()\nif rank == 0:\n    print()\n    print(\"Final data\")\nstdout.flush()\ncomm.Barrier()\nfor r in range(size):\n    if rank == r:\n        print(\"rank \", rank, recv_buf)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-alltoall",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\nif rank == 0:\n    data = np.arange(8) / 10. # NumPy array\n    py_data = {'key1' : 0.0, 'key2' : 11} # Python object\nelse:\n    data = np.zeros(8)\n    py_data = None",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\nif rank == 0:\n    data = np.arange(8) / 10. # NumPy array\n    py_data = {'key1' : 0.0, 'key2' : 11} # Python object\nelse:\n    data = np.zeros(8)\n    py_data = None\nif rank == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "peekOfCode": "size = comm.Get_size()\nassert size == 4\nif rank == 0:\n    data = np.arange(8) / 10. # NumPy array\n    py_data = {'key1' : 0.0, 'key2' : 11} # Python object\nelse:\n    data = np.zeros(8)\n    py_data = None\nif rank == 0:\n    print(\"Original data\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "documentation": {}
    },
    {
        "label": "new_data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "peekOfCode": "new_data = comm.bcast(py_data, root=0)\ncomm.Barrier()\nif rank == 0:\n    print()\n    print(\"Final data\")\nstdout.flush()\ncomm.Barrier()\nprint(\"rank \", rank, data)\nprint(\"rank \", rank, new_data)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-bcast",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, periodicity, reorder=True)\ncoords = grid.Get_coords(rank)\nif rank == 0:\n    print(\"Dim: \" + str(grid.Get_dim()))\n    print(\"Topology: \" + str(grid.Get_topo()))\nprint(\"Rank %d: %s\" % (rank, str(coords)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "peekOfCode": "rank = comm.Get_rank()\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, periodicity, reorder=True)\ncoords = grid.Get_coords(rank)\nif rank == 0:\n    print(\"Dim: \" + str(grid.Get_dim()))\n    print(\"Topology: \" + str(grid.Get_topo()))\nprint(\"Rank %d: %s\" % (rank, str(coords)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "documentation": {}
    },
    {
        "label": "dimensions",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "peekOfCode": "dimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, periodicity, reorder=True)\ncoords = grid.Get_coords(rank)\nif rank == 0:\n    print(\"Dim: \" + str(grid.Get_dim()))\n    print(\"Topology: \" + str(grid.Get_topo()))\nprint(\"Rank %d: %s\" % (rank, str(coords)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "documentation": {}
    },
    {
        "label": "periodicity",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "peekOfCode": "periodicity = (True, True)\ngrid = comm.Create_cart(dimensions, periodicity, reorder=True)\ncoords = grid.Get_coords(rank)\nif rank == 0:\n    print(\"Dim: \" + str(grid.Get_dim()))\n    print(\"Topology: \" + str(grid.Get_topo()))\nprint(\"Rank %d: %s\" % (rank, str(coords)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "peekOfCode": "grid = comm.Create_cart(dimensions, periodicity, reorder=True)\ncoords = grid.Get_coords(rank)\nif rank == 0:\n    print(\"Dim: \" + str(grid.Get_dim()))\n    print(\"Topology: \" + str(grid.Get_topo()))\nprint(\"Rank %d: %s\" % (rank, str(coords)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "documentation": {}
    },
    {
        "label": "coords",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "peekOfCode": "coords = grid.Get_coords(rank)\nif rank == 0:\n    print(\"Dim: \" + str(grid.Get_dim()))\n    print(\"Topology: \" + str(grid.Get_topo()))\nprint(\"Rank %d: %s\" % (rank, str(coords)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-cartesian",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nn = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\ncomm.Bcast(data, 0)\nif rank == 1:\n    print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nn = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\ncomm.Bcast(data, 0)\nif rank == 1:\n    print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "peekOfCode": "size = comm.Get_size()\nn = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\ncomm.Bcast(data, 0)\nif rank == 1:\n    print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "peekOfCode": "n = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\ncomm.Bcast(data, 0)\nif rank == 1:\n    print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "peekOfCode": "data = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\ncomm.Bcast(data, 0)\nif rank == 1:\n    print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-collective",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "def add(x,y):\n    return x+y\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nmpi_add = MPI.Op.Create(add)\ndata = arange(10 * size, dtype=float) * (rank + 1)\nbuffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nmpi_add = MPI.Op.Create(add)\ndata = arange(10 * size, dtype=float) * (rank + 1)\nbuffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nmpi_add = MPI.Op.Create(add)\ndata = arange(10 * size, dtype=float) * (rank + 1)\nbuffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "size = comm.Get_size()\nmpi_add = MPI.Op.Create(add)\ndata = arange(10 * size, dtype=float) * (rank + 1)\nbuffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "mpi_add",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "mpi_add = MPI.Op.Create(add)\ndata = arange(10 * size, dtype=float) * (rank + 1)\nbuffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "data = arange(10 * size, dtype=float) * (rank + 1)\nbuffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "buffer",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "buffer = zeros(size * 10, float)\nn = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "peekOfCode": "n = comm.reduce(rank, op=mpi_add, root=0) # returns the value\ncomm.Reduce(data, buffer, op=mpi_add, root=0) # in-place modification",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-custom-operator",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.full(n, -1, int)\n# Destination and source for messages (using PROC_NULL for out-of-bounds)\ntgt = rank + 1\nsrc = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.full(n, -1, int)\n# Destination and source for messages (using PROC_NULL for out-of-bounds)\ntgt = rank + 1\nsrc = rank - 1\nif tgt >= size:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "size = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.full(n, -1, int)\n# Destination and source for messages (using PROC_NULL for out-of-bounds)\ntgt = rank + 1\nsrc = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "n = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.full(n, -1, int)\n# Destination and source for messages (using PROC_NULL for out-of-bounds)\ntgt = rank + 1\nsrc = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "data = numpy.full(n, rank, int)\nbuff = numpy.full(n, -1, int)\n# Destination and source for messages (using PROC_NULL for out-of-bounds)\ntgt = rank + 1\nsrc = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL\n# Use a single MPI call to do communication",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "buff",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "buff = numpy.full(n, -1, int)\n# Destination and source for messages (using PROC_NULL for out-of-bounds)\ntgt = rank + 1\nsrc = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL\n# Use a single MPI call to do communication\ncomm.Sendrecv(data, dest=tgt, recvbuf=buff, source=src)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "tgt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "tgt = rank + 1\nsrc = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL\n# Use a single MPI call to do communication\ncomm.Sendrecv(data, dest=tgt, recvbuf=buff, source=src)\nprint(\"  Rank %d: receive buffer is filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "peekOfCode": "src = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL\n# Use a single MPI call to do communication\ncomm.Sendrecv(data, dest=tgt, recvbuf=buff, source=src)\nprint(\"  Rank %d: receive buffer is filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-example",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\ndata = np.arange(2) / 10. + rank  # NumPy array\n# Let's create different Python objects for different MPI tasks\nif rank == 0:\n    py_data = 'foo.bar'\nelif rank == 1:\n    py_data = 12.34",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\ndata = np.arange(2) / 10. + rank  # NumPy array\n# Let's create different Python objects for different MPI tasks\nif rank == 0:\n    py_data = 'foo.bar'\nelif rank == 1:\n    py_data = 12.34\nelif rank == 2:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "peekOfCode": "size = comm.Get_size()\nassert size == 4\ndata = np.arange(2) / 10. + rank  # NumPy array\n# Let's create different Python objects for different MPI tasks\nif rank == 0:\n    py_data = 'foo.bar'\nelif rank == 1:\n    py_data = 12.34\nelif rank == 2:\n    py_data = {'key1' : 99.0, 'key2' : [-1, 2.3]}",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "peekOfCode": "data = np.arange(2) / 10. + rank  # NumPy array\n# Let's create different Python objects for different MPI tasks\nif rank == 0:\n    py_data = 'foo.bar'\nelif rank == 1:\n    py_data = 12.34\nelif rank == 2:\n    py_data = {'key1' : 99.0, 'key2' : [-1, 2.3]}\nelse:\n    py_data = [6.5, 4.3]",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "documentation": {}
    },
    {
        "label": "new_data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "peekOfCode": "new_data = comm.gather(py_data, root=1)\ncomm.Barrier()\nif rank == 0:\n    print()\n    print(\"Final data\")\nstdout.flush()\ncomm.Barrier()\nprint(\"rank \", rank, recv_buf)\nprint(\"rank \", rank, new_data)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-gather",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\ndata = ones((4,4), float) * -1\ndata[1:-1,1:-1] = rank\nrecvbuf_hor = zeros(4, float)\nrecvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, ",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\ndata = ones((4,4), float) * -1\ndata[1:-1,1:-1] = rank\nrecvbuf_hor = zeros(4, float)\nrecvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "size = comm.Get_size()\ndata = ones((4,4), float) * -1\ndata[1:-1,1:-1] = rank\nrecvbuf_hor = zeros(4, float)\nrecvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "data = ones((4,4), float) * -1\ndata[1:-1,1:-1] = rank\nrecvbuf_hor = zeros(4, float)\nrecvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "data[1:-1,1:-1]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "data[1:-1,1:-1] = rank\nrecvbuf_hor = zeros(4, float)\nrecvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)\nnbr_left, nbr_right = grid.Shift(1, 1)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "recvbuf_hor",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "recvbuf_hor = zeros(4, float)\nrecvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)\nnbr_left, nbr_right = grid.Shift(1, 1)\nsendbuf_hor = data[:,1].copy()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "recvbuf_ver",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "recvbuf_ver = zeros(4, float)\ndimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)\nnbr_left, nbr_right = grid.Shift(1, 1)\nsendbuf_hor = data[:,1].copy()\nsendbuf_ver = data[1,:].copy()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "dimensions",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "dimensions = (4, 4)\nperiodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)\nnbr_left, nbr_right = grid.Shift(1, 1)\nsendbuf_hor = data[:,1].copy()\nsendbuf_ver = data[1,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, ",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "periodicity",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "periodicity = (True, True)\ngrid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)\nnbr_left, nbr_right = grid.Shift(1, 1)\nsendbuf_hor = data[:,1].copy()\nsendbuf_ver = data[1,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_left, source=nbr_right)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "grid = comm.Create_cart(dimensions, \n                         periodicity, reorder=True)\n# Shift(direction, displacement)\nnbr_up, nbr_down = grid.Shift(0, 1)\nnbr_left, nbr_right = grid.Shift(1, 1)\nsendbuf_hor = data[:,1].copy()\nsendbuf_ver = data[1,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_left, source=nbr_right)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, ",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "sendbuf_hor",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "sendbuf_hor = data[:,1].copy()\nsendbuf_ver = data[1,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_left, source=nbr_right)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, \n                      dest=nbr_up, source=nbr_down)\ndata[:,-1] = recvbuf_hor\ndata[-1,:] = recvbuf_ver\nsendbuf_hor = data[:,-2].copy()\nsendbuf_ver = data[-2,:].copy()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "sendbuf_ver",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "sendbuf_ver = data[1,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_left, source=nbr_right)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, \n                      dest=nbr_up, source=nbr_down)\ndata[:,-1] = recvbuf_hor\ndata[-1,:] = recvbuf_ver\nsendbuf_hor = data[:,-2].copy()\nsendbuf_ver = data[-2,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, ",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "data[:,-1]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "data[:,-1] = recvbuf_hor\ndata[-1,:] = recvbuf_ver\nsendbuf_hor = data[:,-2].copy()\nsendbuf_ver = data[-2,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_right, source=nbr_left)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, \n                      dest=nbr_down, source=nbr_up)\ndata[:,0] = recvbuf_hor\ndata[0,:] = recvbuf_ver",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "data[-1,:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "data[-1,:] = recvbuf_ver\nsendbuf_hor = data[:,-2].copy()\nsendbuf_ver = data[-2,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_right, source=nbr_left)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, \n                      dest=nbr_down, source=nbr_up)\ndata[:,0] = recvbuf_hor\ndata[0,:] = recvbuf_ver\nif rank == 1:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "sendbuf_hor",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "sendbuf_hor = data[:,-2].copy()\nsendbuf_ver = data[-2,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_right, source=nbr_left)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, \n                      dest=nbr_down, source=nbr_up)\ndata[:,0] = recvbuf_hor\ndata[0,:] = recvbuf_ver\nif rank == 1:\n    print(\"Rank 1:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "sendbuf_ver",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "sendbuf_ver = data[-2,:].copy()\ngrid.Sendrecv(sendbuf_hor, recvbuf=recvbuf_hor, \n                      dest=nbr_right, source=nbr_left)\ngrid.Sendrecv(sendbuf_ver, recvbuf=recvbuf_ver, \n                      dest=nbr_down, source=nbr_up)\ndata[:,0] = recvbuf_hor\ndata[0,:] = recvbuf_ver\nif rank == 1:\n    print(\"Rank 1:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "data[:,0]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "data[:,0] = recvbuf_hor\ndata[0,:] = recvbuf_ver\nif rank == 1:\n    print(\"Rank 1:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "data[0,:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "peekOfCode": "data[0,:] = recvbuf_ver\nif rank == 1:\n    print(\"Rank 1:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-halo-exchange",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.Get_size()\nrank = comm.Get_rank()\nprint(\"I am rank %d in group of %d processes.\" % (rank, size))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "peekOfCode": "size = comm.Get_size()\nrank = comm.Get_rank()\nprint(\"I am rank %d in group of %d processes.\" % (rank, size))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "peekOfCode": "rank = comm.Get_rank()\nprint(\"I am rank %d in group of %d processes.\" % (rank, size))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-hello",
        "documentation": {}
    },
    {
        "label": "calculate_something",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "peekOfCode": "def calculate_something(rank):\n    print(\"Calculating something at rank %d ...\" % rank)\n    for i in range(1000):\n        x = i*5.2 + i**2\n    print(\"... and rank %d is done with calculus.\" % rank)\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nif rank == 0:\n    data = arange(size, dtype=float) * (rank + 1)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nif rank == 0:\n    data = arange(size, dtype=float) * (rank + 1)\n    req = comm.Isend(data, dest=1)    # start a send\n    calculate_something(rank)         # .. do something else ..\n    req.wait()                        # wait for send to finish\n    # safe to read/write data again\nelif rank == 1:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nif rank == 0:\n    data = arange(size, dtype=float) * (rank + 1)\n    req = comm.Isend(data, dest=1)    # start a send\n    calculate_something(rank)         # .. do something else ..\n    req.wait()                        # wait for send to finish\n    # safe to read/write data again\nelif rank == 1:\n    data = empty(size, float)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "peekOfCode": "size = comm.Get_size()\nif rank == 0:\n    data = arange(size, dtype=float) * (rank + 1)\n    req = comm.Isend(data, dest=1)    # start a send\n    calculate_something(rank)         # .. do something else ..\n    req.wait()                        # wait for send to finish\n    # safe to read/write data again\nelif rank == 1:\n    data = empty(size, float)\n    req = comm.Irecv(data, source=0)  # post a receive",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-isend",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\ndata = numpy.empty(100, dtype=float)\nif rank == 0:\n    data[:] = numpy.arange(100, dtype=float)\n    comm.Send([data, 100, MPI.DOUBLE], dest=1)\nelif rank == 1:\n    comm.Recv([data, 100, MPI.DOUBLE], source=0)\nif rank == 1:\n    print(\"Received:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "peekOfCode": "rank = comm.Get_rank()\ndata = numpy.empty(100, dtype=float)\nif rank == 0:\n    data[:] = numpy.arange(100, dtype=float)\n    comm.Send([data, 100, MPI.DOUBLE], dest=1)\nelif rank == 1:\n    comm.Recv([data, 100, MPI.DOUBLE], source=0)\nif rank == 1:\n    print(\"Received:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "peekOfCode": "data = numpy.empty(100, dtype=float)\nif rank == 0:\n    data[:] = numpy.arange(100, dtype=float)\n    comm.Send([data, 100, MPI.DOUBLE], dest=1)\nelif rank == 1:\n    comm.Recv([data, 100, MPI.DOUBLE], source=0)\nif rank == 1:\n    print(\"Received:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-manual-buffer",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\ndata = numpy.arange(10, dtype=float) * (rank + 1)  # send buffer\nbuffer = numpy.zeros(10, dtype=float)              # receive buffer\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\ndata = numpy.arange(10, dtype=float) * (rank + 1)  # send buffer\nbuffer = numpy.zeros(10, dtype=float)              # receive buffer\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:\n    tgt = MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "size = comm.Get_size()\ndata = numpy.arange(10, dtype=float) * (rank + 1)  # send buffer\nbuffer = numpy.zeros(10, dtype=float)              # receive buffer\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:\n    tgt = MPI.PROC_NULL\nreq = []",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "data = numpy.arange(10, dtype=float) * (rank + 1)  # send buffer\nbuffer = numpy.zeros(10, dtype=float)              # receive buffer\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:\n    tgt = MPI.PROC_NULL\nreq = []\nreq.append(comm.Isend(data, dest=tgt))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "buffer",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "buffer = numpy.zeros(10, dtype=float)              # receive buffer\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:\n    tgt = MPI.PROC_NULL\nreq = []\nreq.append(comm.Isend(data, dest=tgt))\nreq.append(comm.Irecv(buffer, source=src))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "tgt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "tgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:\n    tgt = MPI.PROC_NULL\nreq = []\nreq.append(comm.Isend(data, dest=tgt))\nreq.append(comm.Irecv(buffer, source=src))\nMPI.Request.waitall(req)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "src = rank - 1\nif rank == 0:\n    src = MPI.PROC_NULL\nif rank == size - 1:\n    tgt = MPI.PROC_NULL\nreq = []\nreq.append(comm.Isend(data, dest=tgt))\nreq.append(comm.Irecv(buffer, source=src))\nMPI.Request.waitall(req)\nprint('[{0:2}] Received: {1}'.format(rank, buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "req",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "peekOfCode": "req = []\nreq.append(comm.Isend(data, dest=tgt))\nreq.append(comm.Irecv(buffer, source=src))\nMPI.Request.waitall(req)\nprint('[{0:2}] Received: {1}'.format(rank, buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-msg-chain",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nn = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\nif rank == 0:\n    for i in range(1, size):\n        comm.Send(data, i)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nn = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\nif rank == 0:\n    for i in range(1, size):\n        comm.Send(data, i)\nelse:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "peekOfCode": "size = comm.Get_size()\nn = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\nif rank == 0:\n    for i in range(1, size):\n        comm.Send(data, i)\nelse:\n    comm.Recv(data, 0)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "peekOfCode": "n = 10\ndata = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\nif rank == 0:\n    for i in range(1, size):\n        comm.Send(data, i)\nelse:\n    comm.Recv(data, 0)\nif rank == 1:",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "peekOfCode": "data = empty(n, float)\nif rank == 0:\n    data = arange(n, dtype=float)\nif rank == 0:\n    for i in range(1, size):\n        comm.Send(data, i)\nelse:\n    comm.Recv(data, 0)\nif rank == 1:\n    print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-p2p",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\ndata = arange(size * 10, dtype=float) * (rank + 1)\nbuffer = empty(size * 10, float)\nn = comm.reduce(rank, op=MPI.MAX, root=0)  # returns the value\ncomm.Reduce(data, buffer, op=MPI.SUM, root=0)  # in-place modification\nif rank == 0:\n    print(\"Sum of ranks: \" + str(n))\n    print(\"Received data:\\n\" + str(buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\ndata = arange(size * 10, dtype=float) * (rank + 1)\nbuffer = empty(size * 10, float)\nn = comm.reduce(rank, op=MPI.MAX, root=0)  # returns the value\ncomm.Reduce(data, buffer, op=MPI.SUM, root=0)  # in-place modification\nif rank == 0:\n    print(\"Sum of ranks: \" + str(n))\n    print(\"Received data:\\n\" + str(buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "peekOfCode": "size = comm.Get_size()\ndata = arange(size * 10, dtype=float) * (rank + 1)\nbuffer = empty(size * 10, float)\nn = comm.reduce(rank, op=MPI.MAX, root=0)  # returns the value\ncomm.Reduce(data, buffer, op=MPI.SUM, root=0)  # in-place modification\nif rank == 0:\n    print(\"Sum of ranks: \" + str(n))\n    print(\"Received data:\\n\" + str(buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "peekOfCode": "data = arange(size * 10, dtype=float) * (rank + 1)\nbuffer = empty(size * 10, float)\nn = comm.reduce(rank, op=MPI.MAX, root=0)  # returns the value\ncomm.Reduce(data, buffer, op=MPI.SUM, root=0)  # in-place modification\nif rank == 0:\n    print(\"Sum of ranks: \" + str(n))\n    print(\"Received data:\\n\" + str(buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "documentation": {}
    },
    {
        "label": "buffer",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "peekOfCode": "buffer = empty(size * 10, float)\nn = comm.reduce(rank, op=MPI.MAX, root=0)  # returns the value\ncomm.Reduce(data, buffer, op=MPI.SUM, root=0)  # in-place modification\nif rank == 0:\n    print(\"Sum of ranks: \" + str(n))\n    print(\"Received data:\\n\" + str(buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "peekOfCode": "n = comm.reduce(rank, op=MPI.MAX, root=0)  # returns the value\ncomm.Reduce(data, buffer, op=MPI.SUM, root=0)  # in-place modification\nif rank == 0:\n    print(\"Sum of ranks: \" + str(n))\n    print(\"Received data:\\n\" + str(buffer))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-reduce",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\nif rank == 0:\n    data = np.arange(8) / 10.  # NumPy array\n    # Python sequence, lenght has to be equal number to MPI tasks\n    py_data = ['foo', 'bar', 11.2, {'key' : 22}]\nelse:\n    data = None",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4\nif rank == 0:\n    data = np.arange(8) / 10.  # NumPy array\n    # Python sequence, lenght has to be equal number to MPI tasks\n    py_data = ['foo', 'bar', 11.2, {'key' : 22}]\nelse:\n    data = None\n    py_data = None",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "peekOfCode": "size = comm.Get_size()\nassert size == 4\nif rank == 0:\n    data = np.arange(8) / 10.  # NumPy array\n    # Python sequence, lenght has to be equal number to MPI tasks\n    py_data = ['foo', 'bar', 11.2, {'key' : 22}]\nelse:\n    data = None\n    py_data = None\nrecv_buf = np.zeros(2)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "documentation": {}
    },
    {
        "label": "recv_buf",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "peekOfCode": "recv_buf = np.zeros(2)\nif rank == 0:\n    print(\"Original data\")\nstdout.flush()\ncomm.Barrier()\nprint(\"rank \", rank, data)\nprint(\"rank \", rank, py_data)\nstdout.flush()\ncomm.Scatter(data, recv_buf, root=0)\nnew_data = comm.scatter(py_data, root=0)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "documentation": {}
    },
    {
        "label": "new_data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "peekOfCode": "new_data = comm.scatter(py_data, root=0)\ncomm.Barrier()\nif rank == 0:\n    print()\n    print(\"Final data\")\nstdout.flush()\ncomm.Barrier()\nprint(\"rank \", rank, recv_buf)\nprint(\"rank \", rank, new_data)",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-scatter",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-send-array",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-send-array",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nif rank == 0:\n    data = numpy.arange(100, dtype=float)\n    comm.Send(data, dest=1)\nelif rank == 1:\n    data = numpy.empty(100, dtype=float)\n    comm.Recv(data, source=0)\nif rank == 1:\n    print(\"Received:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-send-array",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-send-array",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-send-array",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = numpy.arange(100, dtype=float)\n    comm.Send(data, dest=1)\nelif rank == 1:\n    data = numpy.empty(100, dtype=float)\n    comm.Recv(data, source=0)\nif rank == 1:\n    print(\"Received:\\n\" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-send-array",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-send",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-send",
        "peekOfCode": "comm = MPI.COMM_WORLD  # communicator object containing all processes\nrank = comm.Get_rank()\nif rank == 0:\n   data = {'a': 7, 'b': 3.14}\n   comm.send(data, dest=1)\nelif rank == 1:\n   data = comm.recv(source=0)\nif rank == 1:\n   print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-send",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-send",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-send",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n   data = {'a': 7, 'b': 3.14}\n   comm.send(data, dest=1)\nelif rank == 1:\n   data = comm.recv(source=0)\nif rank == 1:\n   print(\"Received: \" + str(data))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-send",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\ndata = numpy.arange(10, dtype=float) * (rank + 1) # send buffer\nbuffer = numpy.empty(10, float)                   # receive buffer\nif rank == 0:\n    comm.Sendrecv(data, dest=1, recvbuf=buffer, source=1)\nelif rank == 1:\n    comm.Sendrecv(data, dest=0, recvbuf=buffer, source=0)\nprint(\"Rank %d: %s\" % (rank, str(buffer)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "peekOfCode": "rank = comm.Get_rank()\ndata = numpy.arange(10, dtype=float) * (rank + 1) # send buffer\nbuffer = numpy.empty(10, float)                   # receive buffer\nif rank == 0:\n    comm.Sendrecv(data, dest=1, recvbuf=buffer, source=1)\nelif rank == 1:\n    comm.Sendrecv(data, dest=0, recvbuf=buffer, source=0)\nprint(\"Rank %d: %s\" % (rank, str(buffer)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "peekOfCode": "data = numpy.arange(10, dtype=float) * (rank + 1) # send buffer\nbuffer = numpy.empty(10, float)                   # receive buffer\nif rank == 0:\n    comm.Sendrecv(data, dest=1, recvbuf=buffer, source=1)\nelif rank == 1:\n    comm.Sendrecv(data, dest=0, recvbuf=buffer, source=0)\nprint(\"Rank %d: %s\" % (rank, str(buffer)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "documentation": {}
    },
    {
        "label": "buffer",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "peekOfCode": "buffer = numpy.empty(10, float)                   # receive buffer\nif rank == 0:\n    comm.Sendrecv(data, dest=1, recvbuf=buffer, source=1)\nelif rank == 1:\n    comm.Sendrecv(data, dest=0, recvbuf=buffer, source=0)\nprint(\"Rank %d: %s\" % (rank, str(buffer)))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-sendrecv",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\ncolor = rank % 4\nlocal_comm = comm.Split(color)\nlocal_rank = local_comm.Get_rank()\nprint(\"Global rank: %d  Local rank: %d\" % (rank, local_rank))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "peekOfCode": "rank = comm.Get_rank()\ncolor = rank % 4\nlocal_comm = comm.Split(color)\nlocal_rank = local_comm.Get_rank()\nprint(\"Global rank: %d  Local rank: %d\" % (rank, local_rank))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "peekOfCode": "color = rank % 4\nlocal_comm = comm.Split(color)\nlocal_rank = local_comm.Get_rank()\nprint(\"Global rank: %d  Local rank: %d\" % (rank, local_rank))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "documentation": {}
    },
    {
        "label": "local_comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "peekOfCode": "local_comm = comm.Split(color)\nlocal_rank = local_comm.Get_rank()\nprint(\"Global rank: %d  Local rank: %d\" % (rank, local_rank))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "documentation": {}
    },
    {
        "label": "local_rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "peekOfCode": "local_rank = local_comm.Get_rank()\nprint(\"Global rank: %d  Local rank: %d\" % (rank, local_rank))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-split",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-status",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-status",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nif rank == 0:\n    data = [1,3,5,7]\n    comm.send(data, dest=1)\nif rank == 1:\n    info = MPI.Status()\n    data = comm.recv(source=0, status=info)\n    print(\"Received %d bytes of data.\" % info.Get_count())\n    print(\"Received %d integers.\" % info.Get_elements(MPI.INT))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-status",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.mpi-status",
        "description": "大规模计算(updating).code.hpc-python-master.demos.mpi-status",
        "peekOfCode": "rank = comm.Get_rank()\nif rank == 0:\n    data = [1,3,5,7]\n    comm.send(data, dest=1)\nif rank == 1:\n    info = MPI.Status()\n    data = comm.recv(source=0, status=info)\n    print(\"Received %d bytes of data.\" % info.Get_count())\n    print(\"Received %d integers.\" % info.Get_elements(MPI.INT))",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.mpi-status",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "peekOfCode": "def f(x):\n    return x**2\npool = Pool(8)\n# calculate x**2 in parallel for x in 0..9\nresult = pool.map(f, range(10))\nprint(result)\n# non-blocking alternative\nresult = pool.map_async(f, range(10))\nwhile not result.ready():\n    print(\"waiting...\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "documentation": {}
    },
    {
        "label": "pool",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "peekOfCode": "pool = Pool(8)\n# calculate x**2 in parallel for x in 0..9\nresult = pool.map(f, range(10))\nprint(result)\n# non-blocking alternative\nresult = pool.map_async(f, range(10))\nwhile not result.ready():\n    print(\"waiting...\")\n    time.sleep(1)\nprint(result.get())",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "peekOfCode": "result = pool.map(f, range(10))\nprint(result)\n# non-blocking alternative\nresult = pool.map_async(f, range(10))\nwhile not result.ready():\n    print(\"waiting...\")\n    time.sleep(1)\nprint(result.get())",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "peekOfCode": "result = pool.map_async(f, range(10))\nwhile not result.ready():\n    print(\"waiting...\")\n    time.sleep(1)\nprint(result.get())",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool-map",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "peekOfCode": "def f(x):\n    return x**2\npool = Pool(8)\n# Blocking execution (with a single process)\nresult = pool.apply(f, [4])\nprint(result)\n# Non-blocking execution \"in the background\"\nresult = pool.apply_async(f, [12])\nwhile not result.ready():\n    print(\"waiting...\")",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "documentation": {}
    },
    {
        "label": "pool",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "peekOfCode": "pool = Pool(8)\n# Blocking execution (with a single process)\nresult = pool.apply(f, [4])\nprint(result)\n# Non-blocking execution \"in the background\"\nresult = pool.apply_async(f, [12])\nwhile not result.ready():\n    print(\"waiting...\")\n    time.sleep(1)\nprint(result.get())",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "peekOfCode": "result = pool.apply(f, [4])\nprint(result)\n# Non-blocking execution \"in the background\"\nresult = pool.apply_async(f, [12])\nwhile not result.ready():\n    print(\"waiting...\")\n    time.sleep(1)\nprint(result.get())",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "description": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "peekOfCode": "result = pool.apply_async(f, [12])\nwhile not result.ready():\n    print(\"waiting...\")\n    time.sleep(1)\nprint(result.get())",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.pool",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "description": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "peekOfCode": "def squared(a):\n    for i in range(len(a)):\n        a[i] = a[i] * a[i]\nnumbers = Array('i', range(10))\np = Process(target=squared, args=[numbers])\np.start()\np.join()\nprint(numbers[:])",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "description": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "peekOfCode": "numbers = Array('i', range(10))\np = Process(target=squared, args=[numbers])\np.start()\np.join()\nprint(numbers[:])",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "description": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "peekOfCode": "p = Process(target=squared, args=[numbers])\np.start()\np.join()\nprint(numbers[:])",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.shared-mem",
        "documentation": {}
    },
    {
        "label": "hello",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.spawn",
        "description": "大规模计算(updating).code.hpc-python-master.demos.spawn",
        "peekOfCode": "def hello(name):\n    print('Hello ' + name)\n    print('My PID is {0}'.format(os.getpid()))\n    print(\"My parent's PID is {0}\".format(os.getppid()))\n# Create a new process\np = Process(target=hello, args=['Alice'])\n# Start the process\np.start()\nprint('Spawned a new process from PID {0}'.format(os.getpid()))\n# End the process",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.spawn",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.spawn",
        "description": "大规模计算(updating).code.hpc-python-master.demos.spawn",
        "peekOfCode": "p = Process(target=hello, args=['Alice'])\n# Start the process\np.start()\nprint('Spawned a new process from PID {0}'.format(os.getpid()))\n# End the process\np.join()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.spawn",
        "documentation": {}
    },
    {
        "label": "f",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "peekOfCode": "def f(q, i):\n    while True:\n        x = q.get()\n        if x is None:\n            break\n        print('[{0}] {1}'.format(i, x**2))\nq = Queue()\nfor i in range(100):\n    q.put(i)\n# task queue: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..., 99]",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "peekOfCode": "q = Queue()\nfor i in range(100):\n    q.put(i)\n# task queue: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ..., 99]\nn = 3   # no. of processes\np = []  # list of processes\nfor i in range(n):\n    p.append(Process(target=f, args=[q, i]))\n    q.put(None)  # add sentinels to signal STOP\n# start work on all processes",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "peekOfCode": "n = 3   # no. of processes\np = []  # list of processes\nfor i in range(n):\n    p.append(Process(target=f, args=[q, i]))\n    q.put(None)  # add sentinels to signal STOP\n# start work on all processes\nfor i in range(n):\n    p[i].start()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "peekOfCode": "p = []  # list of processes\nfor i in range(n):\n    p.append(Process(target=f, args=[q, i]))\n    q.put(None)  # add sentinels to signal STOP\n# start work on all processes\nfor i in range(n):\n    p[i].start()",
        "detail": "大规模计算(updating).code.hpc-python-master.demos.task-queue",
        "documentation": {}
    },
    {
        "label": "ffibuilder",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.build_evolve",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.build_evolve",
        "peekOfCode": "ffibuilder = FFI()\nffibuilder.cdef(\"\"\"\n         void evolve(double *u, double *u_previous, int nx, int ny,\n                     double a, double dt, double dx2, double dy2);\n         \"\"\")\nffibuilder.set_source(\"_evolve\",  # name of the output C extension\n\"\"\"\n         void evolve(double *u, double *u_previous, int nx, int ny,\n                     double a, double dt, double dx2, double dy2);\n\"\"\",",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.build_evolve",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    u_ptr = ffi.cast(\"double *\", ffi.from_buffer(u))\n    u_previous_ptr = ffi.cast(\"double *\", ffi.from_buffer(u_previous))\n    nx, ny = u.shape\n    lib.evolve(u_ptr, u_previous_ptr, nx, ny, a, dt, dx2, dy2)",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    u_ptr = ffi.cast(\"double *\", ffi.from_buffer(u))\n    u_previous_ptr = ffi.cast(\"double *\", ffi.from_buffer(u_previous))\n    nx, ny = u.shape",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cffi",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_cython",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.heat_main",
        "documentation": {}
    },
    {
        "label": "ext",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.setup",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.setup",
        "peekOfCode": "ext = Extension(\"evolve_cyt\",\n                sources=[\"evolve_cyt.pyx\", \"evolve.c\"])\nsetup(\n     ext_modules=cythonize(ext)\n)",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.setup",
        "documentation": {}
    },
    {
        "label": "ext",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.solution.setup2",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.solution.setup2",
        "peekOfCode": "ext = Extension(\"evolve_cyt\",\n                sources=[\"evolve_cyt.pyx\",],\n                libraries=['evolve',],\n                library_dirs=['.',])\nsetup(\n     ext_modules=cythonize(ext)\n)",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.solution.setup2",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            u[i, j] = u_previous[i, j] + a * dt * ( \\",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.c.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.interface.c.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.c.heat_main",
        "documentation": {}
    },
    {
        "label": "evolve_py",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "peekOfCode": "def evolve_py(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            u[i, j] = u_previous[i, j] + a * dt * ( \\",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve_py(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.solution.heat_main",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            u[i, j] = u_previous[i, j] + a * dt * ( \\",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.interface.fortran.heat_main",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4, 'Number of MPI tasks has to be 4.'\nif rank == 0:\n    print('Broadcast:')\n# Simple broadcast\nif rank == 0:\n    data = numpy.arange(8)\nelse:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4, 'Number of MPI tasks has to be 4.'\nif rank == 0:\n    print('Broadcast:')\n# Simple broadcast\nif rank == 0:\n    data = numpy.arange(8)\nelse:\n    data = numpy.empty(8, int)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "size = comm.Get_size()\nassert size == 4, 'Number of MPI tasks has to be 4.'\nif rank == 0:\n    print('Broadcast:')\n# Simple broadcast\nif rank == 0:\n    data = numpy.arange(8)\nelse:\n    data = numpy.empty(8, int)\ncomm.Bcast(data, root=0)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "data = numpy.arange(8)\ndata += rank * 8\n# .. and receive buffers\nbuff = numpy.zeros(8, int)\nbuff[:] = -1\n# ... wait for every rank to finish ...\nstdout.flush()\ncomm.barrier()\nif rank == 0:\n    print('')",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "buff",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "buff = numpy.zeros(8, int)\nbuff[:] = -1\n# ... wait for every rank to finish ...\nstdout.flush()\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('-' * 32)\n    print('')\n    print('Data vectors:')",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "buff[:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "buff[:] = -1\n# ... wait for every rank to finish ...\nstdout.flush()\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('-' * 32)\n    print('')\n    print('Data vectors:')\nprint('  Task {0}: {1}'.format(rank, data))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "buff[:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "buff[:] = -1\nstdout.flush()\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('Gather:')\n# Gather equal amount of data from each MPI task\ncomm.Gather(data[:2], buff, root=1)\nprint('  Task {0}: {1}'.format(rank, buff))\n# ... wait for every rank to finish ...",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "buff[:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "buff[:] = -1\nstdout.flush()\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('Reduce:')\n# Calculate partial sums using two communicators\ncolor = rank // 2\nsub_comm = comm.Split(color)\nsub_comm.Reduce(data, buff, op=MPI.SUM, root=0)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "color = rank // 2\nsub_comm = comm.Split(color)\nsub_comm.Reduce(data, buff, op=MPI.SUM, root=0)\nprint('  Task {0}: {1}'.format(rank, buff))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "sub_comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "peekOfCode": "sub_comm = comm.Split(color)\nsub_comm.Reduce(data, buff, op=MPI.SUM, root=0)\nprint('  Task {0}: {1}'.format(rank, buff))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.solution.collectives",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4, 'Number of MPI tasks has to be 4.'\nif rank == 0:\n    print('First collective:')\n# TODO: create data vector at task 0 and send it to everyone else\n#       using collective communication\nif rank == 0:\n    data = ...",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\nassert size == 4, 'Number of MPI tasks has to be 4.'\nif rank == 0:\n    print('First collective:')\n# TODO: create data vector at task 0 and send it to everyone else\n#       using collective communication\nif rank == 0:\n    data = ...\nelse:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "size = comm.Get_size()\nassert size == 4, 'Number of MPI tasks has to be 4.'\nif rank == 0:\n    print('First collective:')\n# TODO: create data vector at task 0 and send it to everyone else\n#       using collective communication\nif rank == 0:\n    data = ...\nelse:\n    data = ...",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "data = ...  # TODO: create the data vectors\n# .. and receive buffers\nbuff = numpy.full(8, -1, int)\n# ... wait for every rank to finish ...\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('-' * 32)\n    print('')\n    print('Data vectors:')",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "buff",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "buff = numpy.full(8, -1, int)\n# ... wait for every rank to finish ...\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('-' * 32)\n    print('')\n    print('Data vectors:')\nprint('  Task {0}: {1}'.format(rank, data))\ncomm.barrier()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "buff[:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "buff[:] = -1\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('d)')\n# TODO: how to get the desired receive buffer using a single collective\n#       communication routine?\n...\nprint('  Task {0}: {1}'.format(rank, buff))\n# ... wait for every rank to finish ...",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "buff[:]",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "peekOfCode": "buff[:] = -1\ncomm.barrier()\nif rank == 0:\n    print('')\n    print('e)')\n# TODO: how to get the desired receive buffer using a single collective\n#       communication routine?\n...\nprint('  Task {0}: {1}'.format(rank, buff))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.collectives.skeleton",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2\n       dy2:            -- \"\" --          , i.e. dy^2\"\"\"\n    u[1:-1, 1:-1] = u_previous[1:-1, 1:-1] + a * dt * ( \\\n            (u_previous[2:, 1:-1] - 2*u_previous[1:-1, 1:-1] + \\",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))\ndef exchange(field):\n    # send down, receive from up\n    sbuf = field[-2,:]\n    rbuf = field[0,:]\n    comm.Sendrecv(sbuf, dest=down, recvbuf=rbuf, source=up)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "exchange",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "def exchange(field):\n    # send down, receive from up\n    sbuf = field[-2,:]\n    rbuf = field[0,:]\n    comm.Sendrecv(sbuf, dest=down, recvbuf=rbuf, source=up)\n    # send up, receive from down\n    sbuf = field[1,:]\n    rbuf = field[-1,:]\n    comm.Sendrecv(sbuf, dest=up, recvbuf=rbuf, source=down)\ndef iterate(field, local_field, local_field0, timesteps, image_interval):",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "def iterate(field, local_field, local_field0, timesteps, image_interval):\n    for m in range(1, timesteps+1):\n        exchange(local_field0)\n        evolve(local_field, local_field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:\n            comm.Gather(local_field[1:-1,:], field, root=0)\n            if rank == 0:\n                write_field(field, m)\ndef main():\n    # Read and scatter the initial temperature field",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "def main():\n    # Read and scatter the initial temperature field\n    if rank == 0:\n        field, field0 = init_fields('bottle.dat')\n        shape = field.shape\n        dtype = field.dtype\n        comm.bcast(shape, 0)  # broadcast dimensions\n        comm.bcast(dtype, 0)  # broadcast data type\n    else:\n        field = None",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\n# Basic parameters\na = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "a = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "timesteps",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "timesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "image_interval",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "image_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "dx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "dy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dx2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "dx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dy2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "dy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "dt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "size = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "up",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "up = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "down",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "peekOfCode": "down = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2\n       dy2:            -- \"\" --          , i.e. dy^2\"\"\"\n    u[1:-1, 1:-1] = u_previous[1:-1, 1:-1] + a * dt * ( \\\n            (u_previous[2:, 1:-1] - 2*u_previous[1:-1, 1:-1] + \\",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))\ndef exchange(field):\n    # TODO: select border rows from the field and add MPI calls to\n    #       exchange them with the neighbouring tasks\n    # send down, receive from up\n    sbuf = ...  # last row of real data",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "exchange",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "def exchange(field):\n    # TODO: select border rows from the field and add MPI calls to\n    #       exchange them with the neighbouring tasks\n    # send down, receive from up\n    sbuf = ...  # last row of real data\n    rbuf = ...  # ghost row\n    comm.Sendrecv(...)\n    # send up, receive from down\n    sbuf = ...  # first row of real data\n    rbuf = ...  # ghost row",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "def iterate(field, local_field, local_field0, timesteps, image_interval):\n    for m in range(1, timesteps+1):\n        exchange(local_field0)\n        evolve(local_field, local_field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:\n            # TODO: gather partial fields to reconstruct the full field\n            comm.Gather(...)\n            if rank == 0:\n                write_field(field, m)\ndef main():",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "def main():\n    # Read and scatter the initial temperature field\n    if rank == 0:\n        field, field0 = init_fields('bottle.dat')\n        shape = field.shape\n        dtype = field.dtype\n        # TODO: send the shape and dtype to everyone else\n    else:\n        field = None\n        # TODO: receive the shape and dtype",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\n# Basic parameters\na = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "a = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "timesteps",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "timesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "image_interval",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "image_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "dx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\n# TODO: find out your rank and communicator size\n# Up/down neighbouring MPI ranks",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "dy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "dy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\n# TODO: find out your rank and communicator size\n# Up/down neighbouring MPI ranks\nup = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "dx2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "dx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\n# TODO: find out your rank and communicator size\n# Up/down neighbouring MPI ranks\nup = rank - 1\ndown = rank + 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "dy2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "dy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\n# TODO: find out your rank and communicator size\n# Up/down neighbouring MPI ranks\nup = rank - 1\ndown = rank + 1\n# TODO: if at the edge of the grid, use MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "dt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "dt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\n# TODO: find out your rank and communicator size\n# Up/down neighbouring MPI ranks\nup = rank - 1\ndown = rank + 1\n# TODO: if at the edge of the grid, use MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "up",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "up = rank - 1\ndown = rank + 1\n# TODO: if at the edge of the grid, use MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "down",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "peekOfCode": "down = rank + 1\n# TODO: if at the edge of the grid, use MPI.PROC_NULL\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2\n       dy2:            -- \"\" --          , i.e. dy^2\"\"\"",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation.skeleton",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))\ndef exchange(field):\n    # send down, receive from up\n    sbuf = field[-2,:]\n    rbuf = field[0,:]\n    comm.Sendrecv(sbuf, dest=down, recvbuf=rbuf, source=up)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "exchange",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "def exchange(field):\n    # send down, receive from up\n    sbuf = field[-2,:]\n    rbuf = field[0,:]\n    comm.Sendrecv(sbuf, dest=down, recvbuf=rbuf, source=up)\n    # send up, receive from down\n    sbuf = field[1,:]\n    rbuf = field[-1,:]\n    comm.Sendrecv(sbuf, dest=up, recvbuf=rbuf, source=down)\ndef iterate(field, local_field, local_field0, timesteps, image_interval):",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "def iterate(field, local_field, local_field0, timesteps, image_interval):\n    for m in range(1, timesteps+1):\n        exchange(local_field0)\n        evolve(local_field, local_field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:\n            comm.Gather(local_field[1:-1,:], field, root=0)\n            if rank == 0:\n                write_field(field, m)\ndef main():\n    # Read and scatter the initial temperature field",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "def main():\n    # Read and scatter the initial temperature field\n    if rank == 0:\n        field, field0 = init_fields('bottle.dat')\n        shape = field.shape\n        dtype = field.dtype\n        comm.bcast(shape, 0)  # broadcast dimensions\n        comm.bcast(dtype, 0)  # broadcast data type\n    else:\n        field = None",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\n# Basic parameters\na = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "a = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "timesteps",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "timesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "image_interval",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "image_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "dx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "dy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dx2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "dx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dy2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "dy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "dt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "dt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef init_fields(filename):",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "size = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef init_fields(filename):\n    # Read the initial temperature field from file",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "up",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "up = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "down",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "peekOfCode": "down = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.heat-equation-cython.solution.heat-p2p",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "peekOfCode": "comm = MPI.COMM_WORLD\nsize = comm.Get_size()\nrank = comm.Get_rank()\nprint(\"I am rank %d in group of %d processes.\" % (rank, size))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "peekOfCode": "size = comm.Get_size()\nrank = comm.Get_rank()\nprint(\"I am rank %d in group of %d processes.\" % (rank, size))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "peekOfCode": "rank = comm.Get_rank()\nprint(\"I am rank %d in group of %d processes.\" % (rank, size))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.hello-world.solution.hello-world",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\nif rank == 0:\n    print(\"Send and Recv:\")\n# Message chain using Send and Recv",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\nif rank == 0:\n    print(\"Send and Recv:\")\n# Message chain using Send and Recv\ntgt = rank + 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "size = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\nif rank == 0:\n    print(\"Send and Recv:\")\n# Message chain using Send and Recv\ntgt = rank + 1\nsrc = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "n = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\nif rank == 0:\n    print(\"Send and Recv:\")\n# Message chain using Send and Recv\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    comm.Send(data, dest=tgt)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "data = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\nif rank == 0:\n    print(\"Send and Recv:\")\n# Message chain using Send and Recv\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    comm.Send(data, dest=tgt)\n    print(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "buff",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "buff = numpy.zeros(n, int)\nif rank == 0:\n    print(\"Send and Recv:\")\n# Message chain using Send and Recv\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    comm.Send(data, dest=tgt)\n    print(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nelse:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "tgt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "tgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    comm.Send(data, dest=tgt)\n    print(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nelse:\n    comm.Recv(buff, source=src)\n    print(\"  Rank %d: received an array filled with %ds.\" % (rank, buff[0]))\n    if rank < size - 1:\n        comm.Send(data, dest=tgt)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "src = rank - 1\nif rank == 0:\n    comm.Send(data, dest=tgt)\n    print(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nelse:\n    comm.Recv(buff, source=src)\n    print(\"  Rank %d: received an array filled with %ds.\" % (rank, buff[0]))\n    if rank < size - 1:\n        comm.Send(data, dest=tgt)\n        print(\"  Rank %d: sent %d elements.\" % (rank, len(data)))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "tgt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "tgt = rank + 1\nsrc = rank - 1\nif rank == 0:          # start of chain; only send\n    comm.Send(data, dest=tgt)\n    print(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nelif rank == size - 1: # end of chain; only receive\n    comm.Recv(buff, source=src)\n    print(\"  Rank %d: received a message from rank %d.\" % (rank, src))\n    print(\"  Rank %d: received an array filled with %ds.\" % (rank, buff[0]))\nelse:                  # middle of chain; send and receive",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "src = rank - 1\nif rank == 0:          # start of chain; only send\n    comm.Send(data, dest=tgt)\n    print(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nelif rank == size - 1: # end of chain; only receive\n    comm.Recv(buff, source=src)\n    print(\"  Rank %d: received a message from rank %d.\" % (rank, src))\n    print(\"  Rank %d: received an array filled with %ds.\" % (rank, buff[0]))\nelse:                  # middle of chain; send and receive\n    comm.Sendrecv(data, dest=tgt, recvbuf=buff, source=src)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "tgt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "tgt = rank + 1\nsrc = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL\n# use the same MPI call to do all communication\ncomm.Sendrecv(data, dest=tgt, recvbuf=buff, source=src)\nprint(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nprint(\"  Rank %d: received a message from rank %d.\" % (rank, src))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "peekOfCode": "src = rank - 1\nif tgt >= size:\n    tgt = MPI.PROC_NULL\nif src < 0:\n    src = MPI.PROC_NULL\n# use the same MPI call to do all communication\ncomm.Sendrecv(data, dest=tgt, recvbuf=buff, source=src)\nprint(\"  Rank %d: sent %d elements to rank %d.\" % (rank, len(data), tgt))\nprint(\"  Rank %d: received a message from rank %d.\" % (rank, src))\nprint(\"  Rank %d: received an array filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-chain.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\n# Simple message exchange\nmeta = {'rank': rank}\nif rank == 0:\n    comm.send(meta, dest=1)\n    msg = comm.recv(source=1)\nelif rank == 1:\n    msg = comm.recv(source=0)\n    comm.send(meta, dest=0)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "peekOfCode": "rank = comm.Get_rank()\n# Simple message exchange\nmeta = {'rank': rank}\nif rank == 0:\n    comm.send(meta, dest=1)\n    msg = comm.recv(source=1)\nelif rank == 1:\n    msg = comm.recv(source=0)\n    comm.send(meta, dest=0)\nprint(\"Rank %d received a message from rank %d.\" % (rank, msg['rank']))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "documentation": {}
    },
    {
        "label": "meta",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "peekOfCode": "meta = {'rank': rank}\nif rank == 0:\n    comm.send(meta, dest=1)\n    msg = comm.recv(source=1)\nelif rank == 1:\n    msg = comm.recv(source=0)\n    comm.send(meta, dest=0)\nprint(\"Rank %d received a message from rank %d.\" % (rank, msg['rank']))\n# Simple message exchange using numpy arrays\nn = 100000",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "peekOfCode": "n = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.empty(n, int)\nif rank == 0:\n    comm.Send(data, dest=1)\n    comm.Recv(buff, source=1)\nelif rank == 1:\n    comm.Recv(buff, source=0)\n    comm.Send(data, dest=0)\nprint(\"Rank %d received an array filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "peekOfCode": "data = numpy.full(n, rank, int)\nbuff = numpy.empty(n, int)\nif rank == 0:\n    comm.Send(data, dest=1)\n    comm.Recv(buff, source=1)\nelif rank == 1:\n    comm.Recv(buff, source=0)\n    comm.Send(data, dest=0)\nprint(\"Rank %d received an array filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "documentation": {}
    },
    {
        "label": "buff",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "peekOfCode": "buff = numpy.empty(n, int)\nif rank == 0:\n    comm.Send(data, dest=1)\n    comm.Recv(buff, source=1)\nelif rank == 1:\n    comm.Recv(buff, source=0)\n    comm.Send(data, dest=0)\nprint(\"Rank %d received an array filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.message-exchange.solution.msg-exchange",
        "documentation": {}
    },
    {
        "label": "evolve_inner",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def evolve_inner(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution (for ghost layer independent elements)\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2\n       dy2:            -- \"\" --          , i.e. dy^2\"\"\"\n    u[1:-1, 1:-1] = u_previous[1:-1, 1:-1] - a * dt * ( \\\n            2*u_previous[1:-1, 1:-1] / dx2 + \\",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "evolve_ghost",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def evolve_ghost(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution (for ghost layer dependent elements)\"\"\"\n    u[1:-1, 1:-1] += a * dt * ( \\\n            (u_previous[2:, 1:-1] + u_previous[:-2, 1:-1]) / dx2 + \\\n            (u_previous[1:-1, 2:] + u_previous[1:-1, :-2]) / dy2 )\n    u_previous[:] = u[:]\ndef init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))\ndef exchange(field):\n    requests = []\n    # send down, receive from up\n    sbuf = field[-2,:].copy()\n    rbuf = field[0,:]",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "exchange",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def exchange(field):\n    requests = []\n    # send down, receive from up\n    sbuf = field[-2,:].copy()\n    rbuf = field[0,:]\n    requests.append(comm.Irecv(rbuf, source=up))\n    requests.append(comm.Isend(sbuf, dest=down))\n    # send up, receive from down\n    sbuf = field[1,:].copy()\n    rbuf = field[-1,:]",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def iterate(field, local_field, local_field0, timesteps, image_interval):\n    for m in range(1, timesteps+1):\n        requests = exchange(local_field0)\n        evolve_inner(local_field, local_field0, a, dt, dx2, dy2)\n        MPI.Request.Waitall(requests)\n        evolve_ghost(local_field, local_field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:\n            comm.Gather(local_field[1:-1,:], field, root=0)\n            if rank == 0:\n                write_field(field, m)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "def main():\n    # Read and scatter the initial temperature field\n    if rank == 0:\n        field, field0 = init_fields('bottle.dat')\n        shape = field.shape\n        dtype = field.dtype\n        comm.bcast(shape, 0)  # broadcast dimensions\n        comm.bcast(dtype, 0)  # broadcast data type\n    else:\n        field = None",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\n# Basic parameters\na = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "a = 0.5                # Diffusion constant\ntimesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "timesteps",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "timesteps = 200        # Number of time-steps to evolve system\nimage_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "image_interval",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "image_interval = 4000  # Write frequency for png files\n# Grid spacings\ndx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "dx = 0.01\ndy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "dy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "dy = 0.01\ndx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "dx2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "dx2 = dx**2\ndy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "dy2",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "dy2 = dy**2\n# For stability, this is the largest interval possible\n# for the size of the time-step:\ndt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "dt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "dt = dx2*dy2 / ( 2*a*(dx2+dy2) )\n# MPI globals\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve_inner(u, u_previous, a, dt, dx2, dy2):",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "size = comm.Get_size()\n# Up/down neighbouring MPI ranks\nup = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve_inner(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution (for ghost layer independent elements)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "up",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "up = rank - 1\nif up < 0:\n    up = MPI.PROC_NULL\ndown = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve_inner(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution (for ghost layer independent elements)\n       u:            new temperature field\n       u_previous:   previous field",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "down",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "peekOfCode": "down = rank + 1\nif down > size - 1:\n    down = MPI.PROC_NULL\ndef evolve_inner(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution (for ghost layer independent elements)\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.heat",
        "documentation": {}
    },
    {
        "label": "comm",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "comm = MPI.COMM_WORLD\nrank = comm.Get_rank()\nsize = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\n# Destination and source for messages\ntgt = rank + 1\nsrc = rank - 1",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "rank",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "rank = comm.Get_rank()\nsize = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\n# Destination and source for messages\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "size = comm.Get_size()\n# Send and receive buffers\nn = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\n# Destination and source for messages\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    print(\"Isend and Irecv:\")",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "n = 100000\ndata = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\n# Destination and source for messages\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    print(\"Isend and Irecv:\")\n# Message chain using Send and Recv\nif rank > 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "data = numpy.full(n, rank, int)\nbuff = numpy.zeros(n, int)\n# Destination and source for messages\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    print(\"Isend and Irecv:\")\n# Message chain using Send and Recv\nif rank > 0:\n    req_recv = comm.Irecv(buff, source=src)",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "buff",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "buff = numpy.zeros(n, int)\n# Destination and source for messages\ntgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    print(\"Isend and Irecv:\")\n# Message chain using Send and Recv\nif rank > 0:\n    req_recv = comm.Irecv(buff, source=src)\nif rank < size - 1:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "tgt",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "tgt = rank + 1\nsrc = rank - 1\nif rank == 0:\n    print(\"Isend and Irecv:\")\n# Message chain using Send and Recv\nif rank > 0:\n    req_recv = comm.Irecv(buff, source=src)\nif rank < size - 1:\n    req_send = comm.Isend(data, dest=tgt)\n    req_send.Wait()",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "src = rank - 1\nif rank == 0:\n    print(\"Isend and Irecv:\")\n# Message chain using Send and Recv\nif rank > 0:\n    req_recv = comm.Irecv(buff, source=src)\nif rank < size - 1:\n    req_send = comm.Isend(data, dest=tgt)\n    req_send.Wait()\n    print(\"  Rank %d: sent %d elements.\" % (rank, len(data)))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "send_tag",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "send_tag = tgt\nif tgt >= size:\n    tgt = MPI.PROC_NULL  # set destination to \"nowhere\" in last rank\n    send_tag = 0         # send tag can't be equal to MPI.PROC_NULL\nreq_recv = comm.Irecv(buff, source=MPI.ANY_SOURCE, tag=rank)\nreq_send = comm.Isend(data, dest=tgt, tag=send_tag)\nreq_send.Wait()\nprint(\"  Rank %d: sent %d elements using tag '%d'.\" % \\\n        (rank, len(data), tgt))\nif rank > 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "req_recv",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "req_recv = comm.Irecv(buff, source=MPI.ANY_SOURCE, tag=rank)\nreq_send = comm.Isend(data, dest=tgt, tag=send_tag)\nreq_send.Wait()\nprint(\"  Rank %d: sent %d elements using tag '%d'.\" % \\\n        (rank, len(data), tgt))\nif rank > 0:\n    info = MPI.Status()\n    req_recv.Wait(info)\n    print(\"  Rank %d: received a message from rank %d.\" %\n            (rank, info.Get_source()))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "req_send",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "description": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "peekOfCode": "req_send = comm.Isend(data, dest=tgt, tag=send_tag)\nreq_send.Wait()\nprint(\"  Rank %d: sent %d elements using tag '%d'.\" % \\\n        (rank, len(data), tgt))\nif rank > 0:\n    info = MPI.Status()\n    req_recv.Wait(info)\n    print(\"  Rank %d: received a message from rank %d.\" %\n            (rank, info.Get_source()))\n    print(\"  Rank %d: received an array filled with %ds.\" % (rank, buff[0]))",
        "detail": "大规模计算(updating).code.hpc-python-master.mpi.non-blocking.solution.msg-chain",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "peekOfCode": "def squared(a, i):\n    a[i] = a[i] * a[i]\nmanager = Manager()\nnumbers = manager.list()\nnumbers.extend(range(10))\np = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "documentation": {}
    },
    {
        "label": "manager",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "peekOfCode": "manager = Manager()\nnumbers = manager.list()\nnumbers.extend(range(10))\np = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()\nprint numbers[:]",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "peekOfCode": "numbers = manager.list()\nnumbers.extend(range(10))\np = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()\nprint numbers[:]",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "peekOfCode": "p = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()\nprint numbers[:]",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.data-manager",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "peekOfCode": "def squared(a, i):\n    a.acquire()\n    a[i] = i * i\n    a.release()\nnumbers = Array('i', range(10))\np = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "peekOfCode": "numbers = Array('i', range(10))\np = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()\nprint(numbers[:])",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "peekOfCode": "p = [Process(target=squared, args=[numbers, i]) for i in range(10)]\nfor i in range(10):\n    p[i].start()\nfor i in range(10):\n    p[i].join()\nprint(numbers[:])",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.data-sharing.solution.shared-memory",
        "documentation": {}
    },
    {
        "label": "count",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "peekOfCode": "def count(pipe, letter):\n    txt = pipe.recv()\n    n = txt.count(letter)\n    pipe.send(n)\n    pipe.close()\nleft, right = Pipe()\np = Process(target=count, args=[right, 'W'])\np.start()\nfasta = Fasta('5ire.fasta.txt')\nchain = fasta['C']",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "peekOfCode": "p = Process(target=count, args=[right, 'W'])\np.start()\nfasta = Fasta('5ire.fasta.txt')\nchain = fasta['C']\nleft.send(chain)\nn = left.recv()\nprint 'Chain C contains %d trypthophans' % n",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "documentation": {}
    },
    {
        "label": "fasta",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "peekOfCode": "fasta = Fasta('5ire.fasta.txt')\nchain = fasta['C']\nleft.send(chain)\nn = left.recv()\nprint 'Chain C contains %d trypthophans' % n",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "documentation": {}
    },
    {
        "label": "chain",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "peekOfCode": "chain = fasta['C']\nleft.send(chain)\nn = left.recv()\nprint 'Chain C contains %d trypthophans' % n",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "peekOfCode": "n = left.recv()\nprint 'Chain C contains %d trypthophans' % n",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.count-w",
        "documentation": {}
    },
    {
        "label": "Fasta",
        "kind": 6,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.fasta",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.fasta",
        "peekOfCode": "class Fasta:\n    \"\"\"\n    Read an amino acid sequence from a Fasta file.\n      self.chains  --  a dict of chains where key is chain ID and value the\n                       amino acid sequence\n      self.filename -- name of the Fasta file\n      self.marker   -- marks the beginning of a chain ID line (default: >)\n      self.pdb      -- ID of the PDB entry (if able to parse it)\n    Example usage:\n      from fasta import Fasta",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.pipes.fasta",
        "documentation": {}
    },
    {
        "label": "squared",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.simple-calculation.solution.square",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.simple-calculation.solution.square",
        "peekOfCode": "def squared(x):\n    print(x**2)\n# create parallel processes\nprocs = [Process(target=squared, args=[x]) for x in range(10)]\n# start all processes\nfor p in procs:\n    p.start()\n# wait for all tasks to finish\nfor p in procs:\n    p.join()",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.simple-calculation.solution.square",
        "documentation": {}
    },
    {
        "label": "procs",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.simple-calculation.solution.square",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.simple-calculation.solution.square",
        "peekOfCode": "procs = [Process(target=squared, args=[x]) for x in range(10)]\n# start all processes\nfor p in procs:\n    p.start()\n# wait for all tasks to finish\nfor p in procs:\n    p.join()",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.simple-calculation.solution.square",
        "documentation": {}
    },
    {
        "label": "Atom",
        "kind": 6,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pdb",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pdb",
        "peekOfCode": "class Atom:\n    \"\"\"\n    Container for atom coordinates with the possibility to store additional\n    information (element and chain ID).\n      self.x        --  X coordinate\n      self.y        --  Y coordinate\n      self.z        --  Z coordinate\n      self.element  --  atom type\n      self.chain    --  chain ID of the atom\n    \"\"\"",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pdb",
        "documentation": {}
    },
    {
        "label": "PDB",
        "kind": 6,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pdb",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pdb",
        "peekOfCode": "class PDB:\n    \"\"\"\n    Read atom coordinates from a PDB file.\n      self.atoms        --  List of Atom() objects containing all ATOM records\n      self.coordinates  --  NumPy array of atom coordinates\n    Example usage:\n      from pdb import PDB\n      pdb = PDB('5ire.pdb')\n      print pdb.coordinates\n      for atom in pdb:",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pdb",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "def average(chunk):\n    '''Calculate the average of multiple coordinates. Returns a tuple of\n       (average, weight) where\n           average -- average coordinate\n           weight  -- no. of coordinates averaged over'''\n    return (sum(chunk) / len(chunk), len(chunk))\nsize = 10\npool = Pool(size)\npdb = PDB('5ire.pdb')\nn = 100",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "size = 10\npool = Pool(size)\npdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n]\n    tasks.append(chunk)\n# submit tasks to the pool",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "pool",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "pool = Pool(size)\npdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n]\n    tasks.append(chunk)\n# submit tasks to the pool\nresult = pool.map(average, tasks)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "pdb",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "pdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n]\n    tasks.append(chunk)\n# submit tasks to the pool\nresult = pool.map(average, tasks)\n# wait for all tasks to finish",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "n = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n]\n    tasks.append(chunk)\n# submit tasks to the pool\nresult = pool.map(average, tasks)\n# wait for all tasks to finish\npool.close()",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "tasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n]\n    tasks.append(chunk)\n# submit tasks to the pool\nresult = pool.map(average, tasks)\n# wait for all tasks to finish\npool.close()\npool.join()\n# collect results",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "result = pool.map(average, tasks)\n# wait for all tasks to finish\npool.close()\npool.join()\n# collect results\naverages = []\nweights = []\nfor avg, w in result:\n    averages.append(avg)\n    weights.append(w)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "averages",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "averages = []\nweights = []\nfor avg, w in result:\n    averages.append(avg)\n    weights.append(w)\naverages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "weights = []\nfor avg, w in result:\n    averages.append(avg)\n    weights.append(w)\naverages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "averages",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "averages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "weights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "origo",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "peekOfCode": "origo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.pool-of-workers",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "def average(chunk):\n    '''Calculate the average of multiple coordinates. Returns a tuple of\n       (average, weight) where\n           average -- average coordinate\n           weight  -- no. of coordinates averaged over'''\n    return (sum(chunk) / len(chunk), len(chunk))\ndef worker(q, r):\n    '''Work through tasks in the queue, calculating the average coordinate\n       and relative weight for each chunk of coordinates.\n         q -- input queue containing arrays of coordinates",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "worker",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "def worker(q, r):\n    '''Work through tasks in the queue, calculating the average coordinate\n       and relative weight for each chunk of coordinates.\n         q -- input queue containing arrays of coordinates\n         r -- output queue for partial results'''\n    while True:\n        chunk = q.get()\n        if chunk is None:\n            break\n        r.put(average(chunk))",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "size = 10\nq = Queue()\nr = Queue()\npdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "q = Queue()\nr = Queue()\npdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# add tasks into the queue",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "r = Queue()\npdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# add tasks into the queue\nfor chunk in tasks:",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "pdb",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "pdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# add tasks into the queue\nfor chunk in tasks:\n    q.put(chunk)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "n = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# add tasks into the queue\nfor chunk in tasks:\n    q.put(chunk)\n# create parallel processes",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "tasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# add tasks into the queue\nfor chunk in tasks:\n    q.put(chunk)\n# create parallel processes\np = []\nfor i in range(size):",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "p = []\nfor i in range(size):\n    p.append(Process(target=worker, args=[q, r]))\n    q.put(None)  # add sentinels to signal STOP\n    p[i].start()\n# wait for all tasks to finish\nfor i in range(size):\n    p[i].join()\n# collect results\naverages = []",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "averages",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "averages = []\nweights = []\nwhile not r.empty():\n    avg, w = r.get()\n    averages.append(avg)\n    weights.append(w)\naverages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "weights = []\nwhile not r.empty():\n    avg, w = r.get()\n    averages.append(avg)\n    weights.append(w)\naverages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "averages",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "averages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "weights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "origo",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "peekOfCode": "origo = sum(averages * weights.T) / len(pdb)\nprint(origo)",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.solution.task-queue",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "def average(chunk):\n    '''Calculate the average of multiple coordinates. Returns a tuple of\n       (average, weight) where\n           average -- average coordinate\n           weight  -- no. of coordinates averaged over'''\n    return (sum(chunk) / len(chunk), len(chunk))\n# TODO: if using Queue, write a new worker() function that processes tasks\n#       from one queue and puts results in another\n# TODO: setup a Pool of Workers or Queue(s)\npdb = PDB('5ire.pdb')",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "pdb",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "pdb = PDB('5ire.pdb')\nn = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# TODO: process all tasks in parallel\nfor chunk in tasks:\n    ...",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "n = 100\n# split into tasks\ntasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# TODO: process all tasks in parallel\nfor chunk in tasks:\n    ...\n# TODO: collect results from each task",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "tasks",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "tasks = []\nfor i in range(0, len(pdb), n):\n    chunk = pdb.coordinates[i:i+n].copy()\n    tasks.append(chunk)\n# TODO: process all tasks in parallel\nfor chunk in tasks:\n    ...\n# TODO: collect results from each task\naverages = []\nweights = [] # no. of coordinates in each chunk",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "averages",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "averages = []\nweights = [] # no. of coordinates in each chunk\n...\naverages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint origo",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "weights = [] # no. of coordinates in each chunk\n...\naverages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint origo",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "averages",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "averages = array(averages)\nweights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint origo",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "weights",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "weights = array(weights, ndmin=2)\n# calculate the center of coordinates\norigo = sum(averages * weights.T) / len(pdb)\nprint origo",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "origo",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "peekOfCode": "origo = sum(averages * weights.T) / len(pdb)\nprint origo",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.center-of-coords",
        "documentation": {}
    },
    {
        "label": "Atom",
        "kind": 6,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.pdb",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.pdb",
        "peekOfCode": "class Atom:\n    \"\"\"\n    Container for atom coordinates with the possibility to store additional\n    information (element and chain ID).\n      self.x        --  X coordinate\n      self.y        --  Y coordinate\n      self.z        --  Z coordinate\n      self.element  --  atom type\n      self.chain    --  chain ID of the atom\n    \"\"\"",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.pdb",
        "documentation": {}
    },
    {
        "label": "PDB",
        "kind": 6,
        "importPath": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.pdb",
        "description": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.pdb",
        "peekOfCode": "class PDB:\n    \"\"\"\n    Read atom coordinates from a PDB file.\n      self.atoms        --  List of Atom() objects containing all ATOM records\n      self.coordinates  --  NumPy array of atom coordinates\n    Example usage:\n      from pdb import PDB\n      pdb = PDB('5ire.pdb')\n      print pdb.coordinates\n      for atom in pdb:",
        "detail": "大规模计算(updating).code.hpc-python-master.multiprocessing.work-distribution.pdb",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "peekOfCode": "arr = np.random.random(size=(10,10))\nmask = arr > 0.5\nprint(arr[mask])\nind = np.nonzero(mask)\nprint(\"Indices\")\nprint(ind)\nprint(\"Values\")\nprint(arr[ind])",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "documentation": {}
    },
    {
        "label": "mask",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "peekOfCode": "mask = arr > 0.5\nprint(arr[mask])\nind = np.nonzero(mask)\nprint(\"Indices\")\nprint(ind)\nprint(\"Values\")\nprint(arr[ind])",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "documentation": {}
    },
    {
        "label": "ind",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "peekOfCode": "ind = np.nonzero(mask)\nprint(\"Indices\")\nprint(ind)\nprint(\"Values\")\nprint(arr[ind])",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.advanced-indexing.solution.index-mask",
        "documentation": {}
    },
    {
        "label": "a",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "peekOfCode": "a = [4, 6, 21.12, 11, 0.23]\nb = np.array(a)\nprint(b)\nc = np.arange(-2.0, 2.01, 0.2)\nprint(c)\nd = np.linspace(0.5, 1.5, 11)\nprint(d)\ndna = 'ACGAATGCAACCGATC'\ne = np.array(dna, dtype='c')\nprint(e)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "peekOfCode": "b = np.array(a)\nprint(b)\nc = np.arange(-2.0, 2.01, 0.2)\nprint(c)\nd = np.linspace(0.5, 1.5, 11)\nprint(d)\ndna = 'ACGAATGCAACCGATC'\ne = np.array(dna, dtype='c')\nprint(e)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "peekOfCode": "c = np.arange(-2.0, 2.01, 0.2)\nprint(c)\nd = np.linspace(0.5, 1.5, 11)\nprint(d)\ndna = 'ACGAATGCAACCGATC'\ne = np.array(dna, dtype='c')\nprint(e)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "documentation": {}
    },
    {
        "label": "d",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "peekOfCode": "d = np.linspace(0.5, 1.5, 11)\nprint(d)\ndna = 'ACGAATGCAACCGATC'\ne = np.array(dna, dtype='c')\nprint(e)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "documentation": {}
    },
    {
        "label": "dna",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "peekOfCode": "dna = 'ACGAATGCAACCGATC'\ne = np.array(dna, dtype='c')\nprint(e)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "documentation": {}
    },
    {
        "label": "e",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "peekOfCode": "e = np.array(dna, dtype='c')\nprint(e)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-creation.solution.create-array",
        "documentation": {}
    },
    {
        "label": "my_list",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "peekOfCode": "my_list = [[1.1, 1.2, 1.3, 1.4], \n           [2.1, 2.2, 2.3, 2.4],\n           [3.1, 3.2, 3.3, 3.4],\n           [4.1, 4.2, 4.3, 4.4],\n           ]\narr = np.array(my_list)\nprint(arr)\nprint()\nprint(arr[1,:])\nprint()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "peekOfCode": "arr = np.array(my_list)\nprint(arr)\nprint()\nprint(arr[1,:])\nprint()\nprint(arr[:,2])\nprint()\narr[:2, :2] = 0.21\nprint(arr)\nprint()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "documentation": {}
    },
    {
        "label": "checker",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "peekOfCode": "checker = np.zeros((8,8))\nchecker[::2, ::2] = 1\nchecker[1::2, 1::2] = 1\nprint(checker)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.array-slicing.solution.slice-2d",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "peekOfCode": "data = np.loadtxt('points_circle.dat')\nplt.plot(data[:,0], data[:,1], 'o')\ntheta = 90.0 * pi / 180.0 \nR = np.array(((cos(theta), -sin(theta)), (sin(theta), cos(theta))))\ndata_rot = np.dot(data, R)\nplt.plot(data_rot[:,0], data_rot[:,1], 'd')\nplt.axis('equal')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "documentation": {}
    },
    {
        "label": "theta",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "peekOfCode": "theta = 90.0 * pi / 180.0 \nR = np.array(((cos(theta), -sin(theta)), (sin(theta), cos(theta))))\ndata_rot = np.dot(data, R)\nplt.plot(data_rot[:,0], data_rot[:,1], 'd')\nplt.axis('equal')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "documentation": {}
    },
    {
        "label": "R",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "peekOfCode": "R = np.array(((cos(theta), -sin(theta)), (sin(theta), cos(theta))))\ndata_rot = np.dot(data, R)\nplt.plot(data_rot[:,0], data_rot[:,1], 'd')\nplt.axis('equal')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "documentation": {}
    },
    {
        "label": "data_rot",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "peekOfCode": "data_rot = np.dot(data, R)\nplt.plot(data_rot[:,0], data_rot[:,1], 'd')\nplt.axis('equal')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-rotation.solution.rotate",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "peekOfCode": "data = np.loadtxt('points_circle.dat')\nplt.plot(data[:,0], data[:,1], 'o')\nvector = np.array((2.1, 1.1))\ndata_trans = data + vector\nplt.plot(data_trans[:,0], data_trans[:,1], 'd')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "documentation": {}
    },
    {
        "label": "vector",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "peekOfCode": "vector = np.array((2.1, 1.1))\ndata_trans = data + vector\nplt.plot(data_trans[:,0], data_trans[:,1], 'd')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "documentation": {}
    },
    {
        "label": "data_trans",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "peekOfCode": "data_trans = data + vector\nplt.plot(data_trans[:,0], data_trans[:,1], 'd')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.broadcast-translation.solution.translate",
        "documentation": {}
    },
    {
        "label": "generate_string",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "peekOfCode": "def generate_string(N, alphabet='ACGT'):\n    base = np.array(alphabet, dtype='c')\n    # Draw N random samples from alphabet\n    dna = np.random.choice(base, N)\n    return dna\n# Perform N random mutations to DNA string\ndef mutate(dna, N):\n    mutated = dna.copy()\n    mutation_sites = np.random.random_integers(0, dna.size - 1, size=N)\n    base = np.array('ACGT', dtype='c')",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "documentation": {}
    },
    {
        "label": "mutate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "peekOfCode": "def mutate(dna, N):\n    mutated = dna.copy()\n    mutation_sites = np.random.random_integers(0, dna.size - 1, size=N)\n    base = np.array('ACGT', dtype='c')\n    new_bases = np.random.choice(base, N)\n    mutated[mutation_sites] = new_bases\n    return mutated\ndna = generate_string(20)\ndna_mutated = mutate(dna, 5)\nprint(\"Original DNA:\", dna.tobytes().decode())",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "documentation": {}
    },
    {
        "label": "dna",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "peekOfCode": "dna = generate_string(20)\ndna_mutated = mutate(dna, 5)\nprint(\"Original DNA:\", dna.tobytes().decode())\nprint(\"Mutated  DNA:\", dna_mutated.tobytes().decode())\nprint(\"Similarity \", np.sum(dna == dna_mutated) / float(dna.size))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "documentation": {}
    },
    {
        "label": "dna_mutated",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "peekOfCode": "dna_mutated = mutate(dna, 5)\nprint(\"Original DNA:\", dna.tobytes().decode())\nprint(\"Mutated  DNA:\", dna_mutated.tobytes().decode())\nprint(\"Similarity \", np.sum(dna == dna_mutated) / float(dna.size))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.solution.mutate",
        "documentation": {}
    },
    {
        "label": "generate_string",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.skeleton",
        "peekOfCode": "def generate_string(N, alphabet='ACGT'):\n    base = np.array(alphabet, dtype='c')\n    # Draw N random samples from alphabet\n    dna = np.random.choice(base, N)\n    return dna\ndna = generate_string(20)\nprint(\"Original DNA\", dna.tobytes().decode())\n# TODO\n# Use numpy.random.random_integers for selecting N mutation sites\n# Utilise then numpy.random.choice for generating the mutations",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.skeleton",
        "documentation": {}
    },
    {
        "label": "dna",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.skeleton",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.skeleton",
        "peekOfCode": "dna = generate_string(20)\nprint(\"Original DNA\", dna.tobytes().decode())\n# TODO\n# Use numpy.random.random_integers for selecting N mutation sites\n# Utilise then numpy.random.choice for generating the mutations\n# and use advanced indexing for creating mutated DNA",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.dna-mutation.skeleton",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "peekOfCode": "dx = 0.10\nxi = np.arange(0, np.pi/2, dx)\n# Function values\nfi = np.sin(xi)\n# Derivative\ndfi = (fi[2:] - fi[:-2]) / (2.0*dx)\n# Compare to cos. Note that derivative was not defined in end points\nf_ref = np.cos(xi[1:-1])\nprint(\"Root mean squared difference:\")\nprint(np.sqrt(np.mean((dfi - f_ref)**2)))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "documentation": {}
    },
    {
        "label": "xi",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "peekOfCode": "xi = np.arange(0, np.pi/2, dx)\n# Function values\nfi = np.sin(xi)\n# Derivative\ndfi = (fi[2:] - fi[:-2]) / (2.0*dx)\n# Compare to cos. Note that derivative was not defined in end points\nf_ref = np.cos(xi[1:-1])\nprint(\"Root mean squared difference:\")\nprint(np.sqrt(np.mean((dfi - f_ref)**2)))\nplt.plot(xi[1:-1], dfi, label=\"sin'\")",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "documentation": {}
    },
    {
        "label": "fi",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "peekOfCode": "fi = np.sin(xi)\n# Derivative\ndfi = (fi[2:] - fi[:-2]) / (2.0*dx)\n# Compare to cos. Note that derivative was not defined in end points\nf_ref = np.cos(xi[1:-1])\nprint(\"Root mean squared difference:\")\nprint(np.sqrt(np.mean((dfi - f_ref)**2)))\nplt.plot(xi[1:-1], dfi, label=\"sin'\")\nplt.plot(xi[1:-1], f_ref, label=\"cos\")\nplt.legend()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "documentation": {}
    },
    {
        "label": "dfi",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "peekOfCode": "dfi = (fi[2:] - fi[:-2]) / (2.0*dx)\n# Compare to cos. Note that derivative was not defined in end points\nf_ref = np.cos(xi[1:-1])\nprint(\"Root mean squared difference:\")\nprint(np.sqrt(np.mean((dfi - f_ref)**2)))\nplt.plot(xi[1:-1], dfi, label=\"sin'\")\nplt.plot(xi[1:-1], f_ref, label=\"cos\")\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "documentation": {}
    },
    {
        "label": "f_ref",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "peekOfCode": "f_ref = np.cos(xi[1:-1])\nprint(\"Root mean squared difference:\")\nprint(np.sqrt(np.mean((dfi - f_ref)**2)))\nplt.plot(xi[1:-1], dfi, label=\"sin'\")\nplt.plot(xi[1:-1], f_ref, label=\"cos\")\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.finite-difference.solution.finite-difference",
        "documentation": {}
    },
    {
        "label": "initialize",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "peekOfCode": "def initialize(size, shape='cross'):\n    if shape == 'random':\n        board = np.random.rand(size, size).round(0).astype(int)\n    elif shape == 'cross':\n        board = np.zeros((size, size), int)\n        board[size//2,:] = 1\n        board[:,size//2] = 1\n    else:\n        raise NotImplementedError('Unknown initial shape')\n    # Periodic boundary conditions",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "documentation": {}
    },
    {
        "label": "update",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "peekOfCode": "def update(board):\n    # number of neighbours that each square has\n    neighbours = np.zeros(board.shape)\n    neighbours[1:, 1:] += board[:-1, :-1]\n    neighbours[1:, :-1] += board[:-1, 1:]\n    neighbours[:-1, 1:] += board[1:, :-1]\n    neighbours[:-1, :-1] += board[1:, 1:]\n    neighbours[:-1, :] += board[1:, :]\n    neighbours[1:, :] += board[:-1, :]\n    neighbours[:, :-1] += board[:, 1:]",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "peekOfCode": "parser = OptionParser(usage='%prog [options]',\n                      version='%prog 1.00')\nparser.add_option('-d', '--dimension', type='int', default=32,\n                  help='Size of the board')\nparser.add_option('-s', '--shape', type='string', default='cross',\n                  help='Initial shape of the board')\nparser.add_option('-n', '--niter', type='int', default=50,\n                  help='Number of iterations')\ndef initialize(size, shape='cross'):\n    if shape == 'random':",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "documentation": {}
    },
    {
        "label": "board",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "peekOfCode": "board = initialize(opt.dimension, opt.shape)\nplt.ion()\nplt.gca().clear()\nplt.imshow(board, cmap = plt.cm.prism)\n# pl.savefig('gof_initial.png')\nfor iter in range(opt.niter):\n    board = update(board)\n    plt.gca().clear()\n    plt.imshow(board, cmap = plt.cm.prism)\n    plt.title('Generation {0}'.format(iter))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.game-of-life.solution.game-of-life",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2\n       dy2:            -- \"\" --          , i.e. dy^2\"\"\"\n    u[1:-1, 1:-1] = u_previous[1:-1, 1:-1] + a * dt * ( \\\n            (u_previous[2:, 1:-1] - 2*u_previous[1:-1, 1:-1] + \\",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step\n       dx2:          grid spacing squared, i.e. dx^2\n       dy2:            -- \"\" --          , i.e. dy^2\"\"\"\n    u[1:-1, 1:-1] = u_previous[1:-1, 1:-1] + a * dt * ( \\",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.solution.heat_main",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "peekOfCode": "def evolve(u, u_previous, a, dt):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    # TODO: determine the new temperature field based on previous values\n    # and the numerical Laplacian according the explicit time evolution method\ndef iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n# TODO: Implement the main iteration loop and write the figure \n# (to a new) file after each 'image_interval' iteration\ndef init_fields(filename):\n# TODO: Read the initial temperature field from file\n# Create also a copy of the field for the previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "peekOfCode": "def init_fields(filename):\n# TODO: Read the initial temperature field from file\n# Create also a copy of the field for the previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    # TODO: determine the new temperature field based on previous values\n    # and the numerical Laplacian according the explicit time evolution method\ndef iterate(field, field0, a, dx, dy, timesteps, image_interval):",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.heat-equation.heat_main",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.input-output.solution.input-output",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.input-output.solution.input-output",
        "peekOfCode": "filename = sys.argv[1]\nxy = np.loadtxt(filename)\nxy[:,1] += 2.5\nnp.savetxt('new-' + filename, xy, fmt='%.6f', header='modified data')",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.input-output.solution.input-output",
        "documentation": {}
    },
    {
        "label": "xy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.input-output.solution.input-output",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.input-output.solution.input-output",
        "peekOfCode": "xy = np.loadtxt(filename)\nxy[:,1] += 2.5\nnp.savetxt('new-' + filename, xy, fmt='%.6f', header='modified data')",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.input-output.solution.input-output",
        "documentation": {}
    },
    {
        "label": "dx",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "peekOfCode": "dx = 0.01\nxi = np.arange(0, np.pi/2, dx)\nxip = (xi[1:] + xi[:-1]) / 2.\ns = np.sum(np.sin(xip) * dx)\nprint(\"Riemann sum: {0:f}\".format(s))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "documentation": {}
    },
    {
        "label": "xi",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "peekOfCode": "xi = np.arange(0, np.pi/2, dx)\nxip = (xi[1:] + xi[:-1]) / 2.\ns = np.sum(np.sin(xip) * dx)\nprint(\"Riemann sum: {0:f}\".format(s))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "documentation": {}
    },
    {
        "label": "xip",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "peekOfCode": "xip = (xi[1:] + xi[:-1]) / 2.\ns = np.sum(np.sin(xip) * dx)\nprint(\"Riemann sum: {0:f}\".format(s))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "peekOfCode": "s = np.sum(np.sin(xip) * dx)\nprint(\"Riemann sum: {0:f}\".format(s))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.integration.solution.riemann-sum",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "peekOfCode": "A = np.random.random((2,2))\nAsym = A + A.T\nB = np.random.random((2,2))\nBsym = B + B.T\nC = np.dot(Asym, Bsym)\nprint(C)\neigs = np.linalg.eigvals(C)\nprint(\"Eigenvalues are: \" + str(eigs))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "documentation": {}
    },
    {
        "label": "Asym",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "peekOfCode": "Asym = A + A.T\nB = np.random.random((2,2))\nBsym = B + B.T\nC = np.dot(Asym, Bsym)\nprint(C)\neigs = np.linalg.eigvals(C)\nprint(\"Eigenvalues are: \" + str(eigs))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "documentation": {}
    },
    {
        "label": "B",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "peekOfCode": "B = np.random.random((2,2))\nBsym = B + B.T\nC = np.dot(Asym, Bsym)\nprint(C)\neigs = np.linalg.eigvals(C)\nprint(\"Eigenvalues are: \" + str(eigs))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "documentation": {}
    },
    {
        "label": "Bsym",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "peekOfCode": "Bsym = B + B.T\nC = np.dot(Asym, Bsym)\nprint(C)\neigs = np.linalg.eigvals(C)\nprint(\"Eigenvalues are: \" + str(eigs))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "documentation": {}
    },
    {
        "label": "C",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "peekOfCode": "C = np.dot(Asym, Bsym)\nprint(C)\neigs = np.linalg.eigvals(C)\nprint(\"Eigenvalues are: \" + str(eigs))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "documentation": {}
    },
    {
        "label": "eigs",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "peekOfCode": "eigs = np.linalg.eigvals(C)\nprint(\"Eigenvalues are: \" + str(eigs))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.linear-algebra.solution.matrix-product",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "data = np.loadtxt('faulty_data.dat')\nplt.plot(data[:,0], data[:,1], 'o')\nx = data[:,0]\ny = data[:,1]\nmask = y > 35\ny_m = ma.masked_array(y, mask)\nx_m = ma.masked_array(x, mask)\nfit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "x = data[:,0]\ny = data[:,1]\nmask = y > 35\ny_m = ma.masked_array(y, mask)\nx_m = ma.masked_array(x, mask)\nfit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "y = data[:,1]\nmask = y > 35\ny_m = ma.masked_array(y, mask)\nx_m = ma.masked_array(x, mask)\nfit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "mask",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "mask = y > 35\ny_m = ma.masked_array(y, mask)\nx_m = ma.masked_array(x, mask)\nfit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "y_m",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "y_m = ma.masked_array(y, mask)\nx_m = ma.masked_array(x, mask)\nfit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "x_m",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "x_m = ma.masked_array(x, mask)\nfit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "fit_orig",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "fit_orig = np.polyfit(x, y, 2)\nfit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "fit_masked",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "fit_masked = ma.polyfit(x_m, y_m, 2)\nx_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "x_i",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "peekOfCode": "x_i = np.linspace(-6, 6, 35)\nplt.plot(x_i, np.polyval(fit_orig, x_i), label='original')\nplt.plot(x_i, np.polyval(fit_masked, x_i), label='masked')\nplt.legend()\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.masked-array.solution.faulty-data",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "peekOfCode": "filename = sys.argv[1]\nxy = np.loadtxt(filename)\ncoef = np.polyfit(xy[:,0], xy[:,1], 2)\nx = np.linspace(-6, 6, 35)\ny_fit = np.polyval(coef, x)\nplt.plot(xy[:,0], xy[:,1], 'o', markersize=14)\nplt.plot(x, y_fit, linewidth=2)\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "documentation": {}
    },
    {
        "label": "xy",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "peekOfCode": "xy = np.loadtxt(filename)\ncoef = np.polyfit(xy[:,0], xy[:,1], 2)\nx = np.linspace(-6, 6, 35)\ny_fit = np.polyval(coef, x)\nplt.plot(xy[:,0], xy[:,1], 'o', markersize=14)\nplt.plot(x, y_fit, linewidth=2)\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "documentation": {}
    },
    {
        "label": "coef",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "peekOfCode": "coef = np.polyfit(xy[:,0], xy[:,1], 2)\nx = np.linspace(-6, 6, 35)\ny_fit = np.polyval(coef, x)\nplt.plot(xy[:,0], xy[:,1], 'o', markersize=14)\nplt.plot(x, y_fit, linewidth=2)\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "documentation": {}
    },
    {
        "label": "x",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "peekOfCode": "x = np.linspace(-6, 6, 35)\ny_fit = np.polyval(coef, x)\nplt.plot(xy[:,0], xy[:,1], 'o', markersize=14)\nplt.plot(x, y_fit, linewidth=2)\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "documentation": {}
    },
    {
        "label": "y_fit",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "peekOfCode": "y_fit = np.polyval(coef, x)\nplt.plot(xy[:,0], xy[:,1], 'o', markersize=14)\nplt.plot(x, y_fit, linewidth=2)\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.polynomials.solution.fit",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.random-numbers.solution.uniform-normal",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.random-numbers.solution.uniform-normal",
        "peekOfCode": "arr = np.random.random(size=1000)\nprint(\"Uniform distribution\")\nprint(\"Mean: \", np.mean(arr), \"Std. dev.: \", np.std(arr))\nplt.hist(arr, 50)\nplt.title('Uniform distribution')\narr = np.random.normal(size=1000)\nprint(\"Normal distribution\")\nprint(\"Mean: \", np.mean(arr), \"Std. dev.: \", np.std(arr))\nplt.figure()\nplt.hist(arr, 50)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.random-numbers.solution.uniform-normal",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.random-numbers.solution.uniform-normal",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.random-numbers.solution.uniform-normal",
        "peekOfCode": "arr = np.random.normal(size=1000)\nprint(\"Normal distribution\")\nprint(\"Mean: \", np.mean(arr), \"Std. dev.: \", np.std(arr))\nplt.figure()\nplt.hist(arr, 50)\nplt.title('Normal distribution')\nplt.show()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.random-numbers.solution.uniform-normal",
        "documentation": {}
    },
    {
        "label": "my_list",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "peekOfCode": "my_list = [[j +1 + (i + 1) / 10 for i in range(8)] for j in range(8)]\narr = np.array(my_list)\nprint(arr)\nprint()\nsub1, sub2 = np.split(arr, 2)\nprint(sub1)\nprint()\nprint(sub2)\nprint()\norig = np.concatenate((sub1, sub2))",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "peekOfCode": "arr = np.array(my_list)\nprint(arr)\nprint()\nsub1, sub2 = np.split(arr, 2)\nprint(sub1)\nprint()\nprint(sub2)\nprint()\norig = np.concatenate((sub1, sub2))\nprint(orig)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "documentation": {}
    },
    {
        "label": "orig",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "peekOfCode": "orig = np.concatenate((sub1, sub2))\nprint(orig)\nprint()\nsub1, sub2 = np.split(arr, 2, axis=1)\nprint(sub1)\nprint()\nprint(sub2)\nprint()\norig = np.concatenate((sub1, sub2), axis=1)\nprint(orig)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "documentation": {}
    },
    {
        "label": "orig",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "peekOfCode": "orig = np.concatenate((sub1, sub2), axis=1)\nprint(orig)\nprint()",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.split-combine.solution.split-combine",
        "documentation": {}
    },
    {
        "label": "mat",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.numpy.subdiagonal-matrix.solution.subdiagonal",
        "description": "大规模计算(updating).code.hpc-python-master.numpy.subdiagonal-matrix.solution.subdiagonal",
        "peekOfCode": "mat = np.eye(6, k=1) + np.eye(6, k=-1)\nprint(mat)",
        "detail": "大规模计算(updating).code.hpc-python-master.numpy.subdiagonal-matrix.solution.subdiagonal",
        "documentation": {}
    },
    {
        "label": "evolve",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "description": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "peekOfCode": "def evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):\n            u[i, j] = u_previous[i, j] + a * dt * ( \\",
        "detail": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "documentation": {}
    },
    {
        "label": "iterate",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "description": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "peekOfCode": "def iterate(field, field0, a, dx, dy, timesteps, image_interval):\n    \"\"\"Run fixed number of time steps of heat equation\"\"\"\n    dx2 = dx**2\n    dy2 = dy**2\n    # For stability, this is the largest interval possible\n    # for the size of the time-step:\n    dt = dx2*dy2 / ( 2*a*(dx2+dy2) )    \n    for m in range(1, timesteps+1):\n        evolve(field, field0, a, dt, dx2, dy2)\n        if m % image_interval == 0:",
        "detail": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "documentation": {}
    },
    {
        "label": "init_fields",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "description": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "peekOfCode": "def init_fields(filename):\n    # Read the initial temperature field from file\n    field = np.loadtxt(filename)\n    field0 = field.copy() # Array for field of previous time step\n    return field, field0\ndef write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "documentation": {}
    },
    {
        "label": "write_field",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "description": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "peekOfCode": "def write_field(field, step):\n    plt.gca().clear()\n    plt.imshow(field)\n    plt.axis('off')\n    plt.savefig('heat_{0:03d}.png'.format(step))",
        "detail": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "documentation": {}
    },
    {
        "label": "plt.rcParams['image.cmap']",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "description": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "peekOfCode": "plt.rcParams['image.cmap'] = 'BrBG'\ndef evolve(u, u_previous, a, dt, dx2, dy2):\n    \"\"\"Explicit time evolution.\n       u:            new temperature field\n       u_previous:   previous field\n       a:            diffusion constant\n       dt:           time step. \"\"\"\n    n, m = u.shape\n    for i in range(1, n-1):\n        for j in range(1, m-1):",
        "detail": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat_main",
        "description": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat_main",
        "peekOfCode": "def main(input_file='bottle.dat', a=0.5, dx=0.1, dy=0.1, \n         timesteps=200, image_interval=4000):\n    # Initialise the temperature field\n    field, field0 = init_fields(input_file)\n    print(\"Heat equation solver\")\n    print(\"Diffusion constant: {}\".format(a))\n    print(\"Input file: {}\".format(input_file))\n    print(\"Parameters\")\n    print(\"----------\")\n    print(\"  nx={} ny={} dx={} dy={}\".format(field.shape[0], field.shape[1],",
        "detail": "大规模计算(updating).code.hpc-python-master.performance.cprofile.heat_main",
        "documentation": {}
    },
    {
        "label": "fail",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.test.test",
        "description": "大规模计算(updating).code.hpc-python-master.test.test",
        "peekOfCode": "fail = False\nrequired_modules = ['numpy', 'mpi4py', 'matplotlib', 'cython', 'cffi']\nfor mod in required_modules:\n    try:\n        import_module(mod)\n        print(\"{} available\".format(mod))\n    except ImportError:\n        print(\"{} is not available\".format(mod))\n        fail = True\nprint()",
        "detail": "大规模计算(updating).code.hpc-python-master.test.test",
        "documentation": {}
    },
    {
        "label": "required_modules",
        "kind": 5,
        "importPath": "大规模计算(updating).code.hpc-python-master.test.test",
        "description": "大规模计算(updating).code.hpc-python-master.test.test",
        "peekOfCode": "required_modules = ['numpy', 'mpi4py', 'matplotlib', 'cython', 'cffi']\nfor mod in required_modules:\n    try:\n        import_module(mod)\n        print(\"{} available\".format(mod))\n    except ImportError:\n        print(\"{} is not available\".format(mod))\n        fail = True\nprint()\nif fail:",
        "detail": "大规模计算(updating).code.hpc-python-master.test.test",
        "documentation": {}
    },
    {
        "label": "maxIter",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "maxIter = 500\n# Set Dimension and delta\nlenX = lenY = 400 #we set it rectangular\ndelta = 1\n# Boundary condition\nTtop = 100\nTbottom = 0\nTleft = 0\nTright = 0\n# Initial guess of interior grid",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "lenX",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "lenX = lenY = 400 #we set it rectangular\ndelta = 1\n# Boundary condition\nTtop = 100\nTbottom = 0\nTleft = 0\nTright = 0\n# Initial guess of interior grid\nTguess = 30\n# Set colour interpolation and colour map.",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "delta",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "delta = 1\n# Boundary condition\nTtop = 100\nTbottom = 0\nTleft = 0\nTright = 0\n# Initial guess of interior grid\nTguess = 30\n# Set colour interpolation and colour map.\n# You can try set it to 10, or 100 to see the difference",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "Ttop",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "Ttop = 100\nTbottom = 0\nTleft = 0\nTright = 0\n# Initial guess of interior grid\nTguess = 30\n# Set colour interpolation and colour map.\n# You can try set it to 10, or 100 to see the difference\n# You can also try: colourMap = plt.cm.coolwarm\ncolorinterpolation = 50",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "Tbottom",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "Tbottom = 0\nTleft = 0\nTright = 0\n# Initial guess of interior grid\nTguess = 30\n# Set colour interpolation and colour map.\n# You can try set it to 10, or 100 to see the difference\n# You can also try: colourMap = plt.cm.coolwarm\ncolorinterpolation = 50\ncolourMap = plt.cm.jet",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "Tleft",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "Tleft = 0\nTright = 0\n# Initial guess of interior grid\nTguess = 30\n# Set colour interpolation and colour map.\n# You can try set it to 10, or 100 to see the difference\n# You can also try: colourMap = plt.cm.coolwarm\ncolorinterpolation = 50\ncolourMap = plt.cm.jet\n# Set meshgrid",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "Tright",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "Tright = 0\n# Initial guess of interior grid\nTguess = 30\n# Set colour interpolation and colour map.\n# You can try set it to 10, or 100 to see the difference\n# You can also try: colourMap = plt.cm.coolwarm\ncolorinterpolation = 50\ncolourMap = plt.cm.jet\n# Set meshgrid\nX, Y = np.meshgrid(np.arange(0, lenX), np.arange(0, lenY))",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "Tguess",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "Tguess = 30\n# Set colour interpolation and colour map.\n# You can try set it to 10, or 100 to see the difference\n# You can also try: colourMap = plt.cm.coolwarm\ncolorinterpolation = 50\ncolourMap = plt.cm.jet\n# Set meshgrid\nX, Y = np.meshgrid(np.arange(0, lenX), np.arange(0, lenY))\n# Set array size and set the interior value with Tguess\nT = np.empty((lenX, lenY))",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "colorinterpolation",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "colorinterpolation = 50\ncolourMap = plt.cm.jet\n# Set meshgrid\nX, Y = np.meshgrid(np.arange(0, lenX), np.arange(0, lenY))\n# Set array size and set the interior value with Tguess\nT = np.empty((lenX, lenY))\nT.fill(Tguess)\n# Set Boundary condition\nT[(lenY-1):, :] = Ttop\nT[:1, :] = Tbottom",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "colourMap",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "colourMap = plt.cm.jet\n# Set meshgrid\nX, Y = np.meshgrid(np.arange(0, lenX), np.arange(0, lenY))\n# Set array size and set the interior value with Tguess\nT = np.empty((lenX, lenY))\nT.fill(Tguess)\n# Set Boundary condition\nT[(lenY-1):, :] = Ttop\nT[:1, :] = Tbottom\nT[:, (lenX-1):] = Tright",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "大规模计算(updating).code.heat_conduction",
        "description": "大规模计算(updating).code.heat_conduction",
        "peekOfCode": "T = np.empty((lenX, lenY))\nT.fill(Tguess)\n# Set Boundary condition\nT[(lenY-1):, :] = Ttop\nT[:1, :] = Tbottom\nT[:, (lenX-1):] = Tright\nT[:, :1] = Tleft\n# Iteration (We assume that the iteration is convergence in maxIter = 500)\nprint(\"Please wait for a moment\")\nfor iteration in tqdm(range(0, maxIter)):",
        "detail": "大规模计算(updating).code.heat_conduction",
        "documentation": {}
    },
    {
        "label": "LogisticRegression",
        "kind": 6,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "class LogisticRegression:\n    def __init__(self) -> None:\n        self.w = None\n        self.b = None\n    def sigmoid(self, x):\n        return 1 / (1 + np.exp(-x))\n    def fit(self, X, y, lr=0.01, max_iter=1000):\n        X = np.hstack([X, np.ones((X.shape[0], 1))])\n        self.w = np.random.randn(X.shape[1])\n        for i in range(max_iter):",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "data_process",
        "kind": 2,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "def data_process():\n    # 将data加入第一行列表头'Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class'\n    data = pd.read_csv(path, header=None, names= ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class'])\n    # 去掉'Sample code number'列\n    data = data.drop('Sample code number', axis=1)\n    # 0填充'?'\n    data = data.replace('?', 0)\n    # 将所有数据转换为int类型\n    data = data.astype(int)\n    # Z-Score标准化",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "path = 'dataset/breast-cancer-wisconsin.data'\ndef data_process():\n    # 将data加入第一行列表头'Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class'\n    data = pd.read_csv(path, header=None, names= ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class'])\n    # 去掉'Sample code number'列\n    data = data.drop('Sample code number', axis=1)\n    # 0填充'?'\n    data = data.replace('?', 0)\n    # 将所有数据转换为int类型\n    data = data.astype(int)",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "model = LogisticRegression()\n# 训练模型\nmodel.fit(X_train, y_train, lr=0.01, max_iter=1000)\n# 保存模型\nmodel.save('model/logistic_model_implement.npz')\n# 评估模型\ny_pred = model.predict(X_test)\nprint('accuracy:', model.accuracy(y_test, y_pred))\nprint('recall:', model.recall(y_test, y_pred))\n# 混淆矩阵",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "y_pred = model.predict(X_test)\nprint('accuracy:', model.accuracy(y_test, y_pred))\nprint('recall:', model.recall(y_test, y_pred))\n# 混淆矩阵\ny_pred = np.where(y_pred > 0.5, 1, 0)\nconfusion_matrix = np.zeros((2, 2))\nfor i in range(len(y_pred)):\n    confusion_matrix[int(y_test[i]) - 2, int(y_pred[i]) - 2] += 1\nprint('confusion_matrix: ', confusion_matrix)",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "y_pred = np.where(y_pred > 0.5, 1, 0)\nconfusion_matrix = np.zeros((2, 2))\nfor i in range(len(y_pred)):\n    confusion_matrix[int(y_test[i]) - 2, int(y_pred[i]) - 2] += 1\nprint('confusion_matrix: ', confusion_matrix)",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "kind": 5,
        "importPath": "机器学习.hw.实验一 线性模型-实验.debug",
        "description": "机器学习.hw.实验一 线性模型-实验.debug",
        "peekOfCode": "confusion_matrix = np.zeros((2, 2))\nfor i in range(len(y_pred)):\n    confusion_matrix[int(y_test[i]) - 2, int(y_pred[i]) - 2] += 1\nprint('confusion_matrix: ', confusion_matrix)",
        "detail": "机器学习.hw.实验一 线性模型-实验.debug",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "kind": 6,
        "importPath": "机器学习.hw.实验三 Kmeans.kmeans",
        "description": "机器学习.hw.实验三 Kmeans.kmeans",
        "peekOfCode": "class KMeans:\n    # 初始化\n    def __init__(self, k=3, max_iters=300):\n        self.k = k\n        self.max_iters = max_iters\n        # 质心\n        self.centroids = None\n        # 标签\n        self.labels = None\n        # 分类",
        "detail": "机器学习.hw.实验三 Kmeans.kmeans",
        "documentation": {}
    },
    {
        "label": "dataset",
        "kind": 5,
        "importPath": "机器学习.hw.实验三 Kmeans.kmeans",
        "description": "机器学习.hw.实验三 Kmeans.kmeans",
        "peekOfCode": "dataset = pd.read_csv('iris.csv')\n# 实现kmeans算法\nclass KMeans:\n    # 初始化\n    def __init__(self, k=3, max_iters=300):\n        self.k = k\n        self.max_iters = max_iters\n        # 质心\n        self.centroids = None\n        # 标签",
        "detail": "机器学习.hw.实验三 Kmeans.kmeans",
        "documentation": {}
    },
    {
        "label": "bezier_curve",
        "kind": 2,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "def bezier_curve(points, t):\n    n = len(points) - 1\n    return sum(binomial_coeff(n, i) * ((1 - t) ** (n - i)) * (t ** i) * points[i] for i in range(n + 1))\n# 计算二项式系数 \"n choose k\"\ndef binomial_coeff(n, k):\n    return np.math.factorial(n) // (np.math.factorial(k) * np.math.factorial(n - k))\n# 计算 de Casteljau 三角形\ndef de_casteljau(points, t):\n    n = len(points)\n    triangle = [points]",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "binomial_coeff",
        "kind": 2,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "def binomial_coeff(n, k):\n    return np.math.factorial(n) // (np.math.factorial(k) * np.math.factorial(n - k))\n# 计算 de Casteljau 三角形\ndef de_casteljau(points, t):\n    n = len(points)\n    triangle = [points]\n    for i in range(1, n):\n        temp = []\n        for j in range(n - i):\n            temp.append((1 - t) * triangle[i - 1][j] + t * triangle[i - 1][j + 1])",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "de_casteljau",
        "kind": 2,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "def de_casteljau(points, t):\n    n = len(points)\n    triangle = [points]\n    for i in range(1, n):\n        temp = []\n        for j in range(n - i):\n            temp.append((1 - t) * triangle[i - 1][j] + t * triangle[i - 1][j + 1])\n        triangle.append(temp)\n    return triangle\n# 定义控制点",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "points",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "points = np.array([[30, 0], [60, 10], [80, 30], [90, 60], [90, 90]])\n# 计算贝塞尔曲线上的点\nt = 1/4\npoint_on_curve = bezier_curve(points, t)\n# 计算 de Casteljau 三角形\ntriangle = de_casteljau(points, t)\n# 画出控制点\nplt.scatter(points[:,0], points[:,1], color='blue')\n# 画出贝塞尔曲线\nt_values = np.linspace(0, 1, 100)",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "t = 1/4\npoint_on_curve = bezier_curve(points, t)\n# 计算 de Casteljau 三角形\ntriangle = de_casteljau(points, t)\n# 画出控制点\nplt.scatter(points[:,0], points[:,1], color='blue')\n# 画出贝塞尔曲线\nt_values = np.linspace(0, 1, 100)\nbezier_points = np.array([bezier_curve(points, t) for t in t_values])\nplt.plot(bezier_points[:,0], bezier_points[:,1], color='black')",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "point_on_curve",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "point_on_curve = bezier_curve(points, t)\n# 计算 de Casteljau 三角形\ntriangle = de_casteljau(points, t)\n# 画出控制点\nplt.scatter(points[:,0], points[:,1], color='blue')\n# 画出贝塞尔曲线\nt_values = np.linspace(0, 1, 100)\nbezier_points = np.array([bezier_curve(points, t) for t in t_values])\nplt.plot(bezier_points[:,0], bezier_points[:,1], color='black')\n# 画出 de Casteljau 三角形",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "triangle",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "triangle = de_casteljau(points, t)\n# 画出控制点\nplt.scatter(points[:,0], points[:,1], color='blue')\n# 画出贝塞尔曲线\nt_values = np.linspace(0, 1, 100)\nbezier_points = np.array([bezier_curve(points, t) for t in t_values])\nplt.plot(bezier_points[:,0], bezier_points[:,1], color='black')\n# 画出 de Casteljau 三角形\ncolors = ['red', 'green', 'purple', 'orange']\nfor i, level in enumerate(triangle):",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "t_values",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "t_values = np.linspace(0, 1, 100)\nbezier_points = np.array([bezier_curve(points, t) for t in t_values])\nplt.plot(bezier_points[:,0], bezier_points[:,1], color='black')\n# 画出 de Casteljau 三角形\ncolors = ['red', 'green', 'purple', 'orange']\nfor i, level in enumerate(triangle):\n    if i == len(triangle) - 1:\n        break\n    level = np.array(level)\n    plt.plot(level[:,0], level[:,1], color=colors[i % len(colors)])",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "bezier_points",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "bezier_points = np.array([bezier_curve(points, t) for t in t_values])\nplt.plot(bezier_points[:,0], bezier_points[:,1], color='black')\n# 画出 de Casteljau 三角形\ncolors = ['red', 'green', 'purple', 'orange']\nfor i, level in enumerate(triangle):\n    if i == len(triangle) - 1:\n        break\n    level = np.array(level)\n    plt.plot(level[:,0], level[:,1], color=colors[i % len(colors)])\n    # 对每个点添加标签",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    },
    {
        "label": "colors",
        "kind": 5,
        "importPath": "计算机图形学(updating).hw.hw3.bezier",
        "description": "计算机图形学(updating).hw.hw3.bezier",
        "peekOfCode": "colors = ['red', 'green', 'purple', 'orange']\nfor i, level in enumerate(triangle):\n    if i == len(triangle) - 1:\n        break\n    level = np.array(level)\n    plt.plot(level[:,0], level[:,1], color=colors[i % len(colors)])\n    # 对每个点添加标签\n    for j, point in enumerate(level):\n        plt.annotate(f\"{i}-{j}: {point}\", (point[0], point[1]), textcoords=\"offset points\", xytext=(-10,-10), ha='center')\n# 画出曲线上的点",
        "detail": "计算机图形学(updating).hw.hw3.bezier",
        "documentation": {}
    }
]